#pragma once

// This is a JSON API for a restrictive style of JSON that supports binary serialization.
// I want to call this KSON to distinguish itself as NOT json, because it's more like binary.
// The most important feature is the symetric read / write system using templates.
// Used when the file is exclusively generated by the program, a human should not write it.
// This was inspired by a example called "archiver" in the rapidjson examples.
// Limitations:
// Variables must be ordered, no variable can be missing, no variable can be skipped over.
// Keys, objects, arrays do nothing in the binary serializer.
// An annoying limitation is that dynamic sized arrays requires you to specifiy
// the size of an array ahead of the array (like a pascal string).
// Dynamic arrays require you to check the IsReader flag to properly work with dynamic arrays.
// Note:
// Performance is not a goal for the Binary format, because rapidjson is surprisingly fast,
// But the benefit is the lack of care needed with the length of key strings in JSON,
// So you can have descriptive names of every variable without a worry about micro optimization.

// Optimizations:
// avoid lambda callbacks use old school functors if possible.
// you may require to use std::ref if the callback is expensive to copy like std::function.
// I would avoid private members because I think it's better to serialize with a free function.

// TODO:
//-I am noticing that binary bloat is a problem (especially for JSON), anything I can do?
//-all the handlers will print a vague "expected [TYPE]" error, replace rj::BaseReaderHandler
//-should I trigger the read callback while writing for X_CB calls to check for errors?
//-using std::source_location (C++20) I could print the location of where the error occurred.
//-I could include a "key" label in errors that only apply to the next read
// maybe also keep a stack of array/objects?
//-Add a macro definition that enables future debugging features.
//-Maybe a Reserve function (only affects writing memory files)?

// example
#if 0
//shared simple serialization:
//creates: {"i":N, "d":N}
template<class Archive>
void serialize_data_type(Archive& ar, data_type& data)
{
	ar.StartObject();
	ar.Key("i");
	ar.Int(data.i);
	ar.Key("d");
	ar.Double(data.d);
	ar.EndObject();
}

//shared dynamic arrays:
//creates {"size":N, "array":[...]}
template<class Archive>
bool serialize_data_group(Archive& ar, std::vector<data_type>& group_data)
{
	ar.StartObject();
	ar.Key("size");
	uint16_t size = std::size(group_data);
	const size_t max_size = 2;

	//as the writer you are responsible for your own error checks.
	if(Archive::IsWriter)
	{
		if(size > max_size)
		{
			serrf("error group_data too big: %u > %zu\n", val, max_size);
			//assert because all writer errors lead to asserts.
			ASSERT(size <= max_size);
			return false;
		}
	}

	//you must know the size of the array before reading it unlike normal json.
	if(!ar.Uint16_CB(kson_min_max_cb<uint16_t>{test_array_size, 0, max_size}, test_array_size))
	{
		//exit early by checking for errors.
		return false;
	}

#if 0
	//this could replace above to show how to make a custom lambda:
	if(!ar.Uint16_CB(
		[&size](uint16_t val)->bool
			{
				//only called while reading
				if(val > max_size)
				{
					serrf("error group_data too big: %u > %zu\n", val, max_size);
					return false;
				}
				//set the value
				size = val;
				return true;
			},
		//write this size
		size))
#endif

	//the reader needs to allocate the entries to read into
	if(Archive::IsReader)
	{
		data.resize(size);
	}

	ar.Key("array");
	ar.StartArray();
	for(data_type& entry : group_data)
	{
		serialize_data_type(ar, entry);
	}
	ar.EndArray();
	ar.EndObject();
}

//writer setup:
{
	//fill the input with data
	std::vector<data_type> input = {{1,1.1}, {2,2.2}};

	//this stores the result.
	rj::StringBuffer sb;

	//replace "json_memory" with "binary" instead of "json"
	//or "stream" (RWops*) instead of "memory".
	if(!kson_write_json_memory(
			[&](auto& ar) -> bool {
				return serialize_data_group(ar, input);
			},
			sb,
			"store_data_group"))
	{
		//error!
	}
	std::string contents(sb.GetString(), sb.GetLength());
}

//reader setup:
{
	std::vector<data_type> output;

	if(!kson_read_json_memory(
			[&](auto& ar) -> bool {
				return serialize_data_group(ar, output);
			},
			contents.c_str(),
			contents.size(),
			"load_data_group"))
	{
		//error!
	}

	//use output
}

#endif

#include <rapidjson/reader.h>

// needed for the convenience functions
#include <rapidjson/error/en.h>
#include <rapidjson/prettywriter.h>
#include "RWops.h"

namespace rj = rapidjson;

// I got this from stack overflow https://stackoverflow.com/a/41094722
static const int B64index[256] = {
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
	0,	62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,	0,	0,	0,	0,
	0,	0,	0,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10, 11, 12, 13, 14, 15, 16, 17, 18,
	19, 20, 21, 22, 23, 24, 25, 0,	0,	0,	0,	63, 0,	26, 27, 28, 29, 30, 31, 32, 33,
	34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};

inline std::string b64decode(const void* data, const size_t len)
{
	const unsigned char* p = static_cast<const unsigned char*>(data);
	int pad = static_cast<int>(len > 0 && ((len % 4) != 0 || p[len - 1] == '='));
	const size_t L = ((len + 3) / 4 - pad) * 4;
	std::string str(L / 4 * 3 + pad, '\0');

	unsigned char* out = reinterpret_cast<unsigned char*>(str.data());

	for(size_t i = 0, j = 0; i < L; i += 4)
	{
		int n = B64index[p[i]] << 18 | B64index[p[i + 1]] << 12 | B64index[p[i + 2]] << 6 |
				B64index[p[i + 3]];
		out[j++] = static_cast<unsigned char>(n >> 16);
		out[j++] = static_cast<unsigned char>(n >> 8 & 0xFF);
		out[j++] = static_cast<unsigned char>(n & 0xFF);
	}
	if(pad == 1)
	{
		int n = B64index[p[L]] << 18 | B64index[p[L + 1]] << 12;
		out[str.size() - 1] = static_cast<unsigned char>(n >> 16);

		if(len > L + 2 && p[L + 2] != '=')
		{
			n |= B64index[p[L + 2]] << 6;
			str.push_back(static_cast<char>(n >> 8 & 0xFF));
			out = reinterpret_cast<unsigned char*>(str.data());
		}
	}
	return str;
}

/*
 * Base64 encoding/decoding (RFC1341)
 * Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi>
 *
 * This software may be distributed under the terms of the BSD license.
 * See README for more details.
 */

// 2016-12-12 - Gaspard Petit : Slightly modified to return a std::string
// instead of a buffer allocated with malloc.

static const unsigned char base64_table[65] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
/**
 * base64_encode - Base64 encode
 * @src: Data to be encoded
 * @len: Length of the data to be encoded
 * @out_len: Pointer to output length variable, or %NULL if not used
 * Returns: Allocated buffer of out_len bytes of encoded data,
 * or empty string on failure
 */
inline std::string base64_encode(const void* src, size_t len)
{
	unsigned char* out;
	unsigned char* pos;
	const unsigned char* end;
	const unsigned char* in;

	size_t olen;

	olen = 4 * ((len + 2) / 3); /* 3-byte blocks to 4-byte */

	if(olen < len) return std::string(); /* integer overflow */

	std::string outStr;
	outStr.resize(olen);
	out = reinterpret_cast<unsigned char*>(outStr.data());

	end = static_cast<const unsigned char*>(src) + len;
	in = static_cast<const unsigned char*>(src);
	pos = out;
	while(end - in >= 3)
	{
		*pos++ = base64_table[in[0] >> 2];
		*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		*pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
		*pos++ = base64_table[in[2] & 0x3f];
		in += 3;
	}

	if(end != in)
	{
		*pos++ = base64_table[in[0] >> 2];
		if(end - in == 1)
		{
			*pos++ = base64_table[(in[0] & 0x03) << 4];
			*pos++ = '=';
		}
		else
		{
			*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
			*pos++ = base64_table[(in[1] & 0x0f) << 2];
		}
		*pos++ = '=';
	}

	return outStr;
}

template<class Callback>
class internal_bool_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_bool_json_handler<Callback>>
{
public:
	Callback call;

	explicit internal_bool_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected bool\n");
		return false;
	}
	bool Bool(bool b)
	{
		return call(b);
	}
};

template<class Callback>
class internal_int_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_int_json_handler<Callback>>
{
public:
	Callback call;

	explicit internal_int_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected int\n");
		return false;
	}
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		// I don't know why but without this, it triggers -Wsign-compare on gcc
		auto max_size = static_cast<decltype(u)>(std::numeric_limits<int>::max());
		if(u <= max_size)
		{
			return call(u);
		}
		serrf("number too large, max: %u, result: %u\n", max_size, u);
		return false;
	}
};

template<class Callback>
class internal_uint_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint_json_handler<Callback>>
{
public:
	Callback call;

	explicit internal_uint_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected uint\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
};

template<class Callback>
class internal_int64_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_int64_json_handler<Callback>>
{
public:
	Callback call;

	explicit internal_int64_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected int64\n");
		return false;
	}
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
	bool Int64(int64_t i)
	{
		return call(i);
	}
	bool Uint64(uint64_t u)
	{
		if(u <= std::numeric_limits<int64_t>::max())
		{
			return call(u);
		}
		serrf(
			"number too large, max: %" PRId64 ", result: %" PRIu64 "\n",
			std::numeric_limits<int64_t>::max(),
			u);
		return false;
	}
};

template<class Callback>
class internal_uint64_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint64_json_handler<Callback>>
{
public:
	Callback call;

	explicit internal_uint64_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected uint64\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
	bool Uint64(uint64_t u)
	{
		return call(u);
	}
};

template<class Callback>
class internal_double_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_double_json_handler<Callback>>
{
public:
	Callback call;

	explicit internal_double_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected double\n");
		return false;
	}
// I am tempted to disable this, just for strictness.
#if 1
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
#endif
	bool Double(double d)
	{
		return call(d);
	}
};

template<class T, class Callback>
class internal_uint_promote_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint_promote_json_handler<T, Callback>>
{
public:
	Callback call;

	explicit internal_uint_promote_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected unsigned number\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		if(u <= std::numeric_limits<T>::max())
		{
			return call(static_cast<T>(u));
		}
		serrf(
			"number too large, max: %zu, result: %u\n",
			static_cast<size_t>(std::numeric_limits<T>::max()),
			u);
		return false;
	}
};

template<class Callback>
class internal_string_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_string_json_handler<Callback>>
{
public:
	Callback call;
	size_t max_size;

	explicit internal_string_json_handler(Callback cb, size_t max_size_)
	: call(cb)
	, max_size(max_size_)
	{
	}
	bool Default()
	{
		serr("expected string\n");
		return false;
	}
	bool String(const char* str, rj::SizeType length, bool)
	{
		if(length <= max_size)
		{
			return call(str, length);
		}
		serrf("string too large, max: %zu result: %zu\n", max_size, static_cast<size_t>(length));
		return false;
	}
};

template<class Callback>
class internal_data_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_data_json_handler<Callback>>
{
public:
	Callback call;
	size_t max_size;

	explicit internal_data_json_handler(Callback cb, size_t max_size_)
	: call(cb)
	, max_size(max_size_)
	{
	}
	bool Default()
	{
		serr("expected data\n");
		return false;
	}
	bool String(const char* str, rj::SizeType length, bool)
	{
		std::string tmp = b64decode(str, length);
		if(tmp.size() <= max_size)
		{
			return call(tmp.data(), tmp.size());
		}
		serrf("string too large, max: %zu result: %zu\n", max_size, tmp.size());
		return false;
	}
};

class internal_key_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_key_json_handler>
{
public:
	const char* s;
	size_t size;

	explicit internal_key_json_handler(const char* s_, size_t size_)
	: s(s_)
	, size(size_)
	{
	}
	bool Default()
	{
		std::string fuck_null_terminators(s, size);
		serrf("expected key: \"%s\"\n", fuck_null_terminators.c_str());
		return false;
	}
	bool Key(const char* str, rj::SizeType length, bool)
	{
		if(length == size && strncmp(str, s, size) == 0)
		{
			return true;
		}
		std::string fuck_null_terminators(s, size);
		serrf(
			"mismatching keys expected: \"%s\", result: \"%s\"\n",
			str,
			fuck_null_terminators.c_str());
		return false;
	}
};

class internal_startobject_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_startobject_json_handler>
{
public:
	bool Default()
	{
		serr("expected '{'\n");
		return false;
	}
	bool StartObject()
	{
		return true;
	}
};

class internal_endobject_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_endobject_json_handler>
{
public:
	bool Default()
	{
		serr("expected '}'\n");
		return false;
	}
	bool EndObject(rj::SizeType)
	{
		return true;
	}
};

class internal_startarray_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_startarray_json_handler>
{
public:
	bool Default()
	{
		serr("expected '['\n");
		return false;
	}
	bool StartArray()
	{
		return true;
	}
};

class internal_endarray_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_endarray_json_handler>
{
public:
	bool Default()
	{
		serr("expected ']'\n");
		return false;
	}
	bool EndArray(rj::SizeType)
	{
		return true;
	}
};

class internal_null_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_null_json_handler>
{
public:
	bool Default()
	{
		serr("expected null\n");
		return false;
	}
	bool Null()
	{
		return true;
	}
};

template<class T>
struct internal_simple_setter
{
	T& b;
	explicit internal_simple_setter(T& b_)
	: b(b_)
	{
	}
	bool operator()(T b_)
	{
		b = b_;
		return true;
	}
};

struct internal_string_setter
{
	std::string& str;
	bool operator()(const char* str_, rj::SizeType length_)
	{
		str = std::string(str_, length_);
		return true;
	}
};

// used for checking if the double is good.
template<class Callback, class T>
struct internal_finite_double_wrapper
{
	Callback call;
	explicit internal_finite_double_wrapper(Callback cb)
	: call(cb)
	{
	}
	bool operator()(T d)
	{
		if(!std::isfinite(d))
		{
			serrf("invalid float: %f\n", d);
			return false;
		}
		return call(d);
	}
};

template<class JsonStream>
class JsonReader
{
public:
	bool error = false;
	rj::Reader reader;
	JsonStream& stream;

	enum
	{
		IsReader = 1
	};

	explicit JsonReader(JsonStream& stream_)
	: stream(stream_)
	{
		// this wont exist with rapidjson from package managers
		// this requires the newest version of rapidjson from github.
		// it does not help that rapidjson has not icremented their version number,
		// so 1.1.0 could be the package version, but 1.1.0 is also the github version...
		reader.IterativeParseInit();
	}

	bool good() const
	{
		return !error;
	}

	bool is_complete() const
	{
		return reader.IterativeParseComplete();
	}

	bool Null()
	{
		if(error) return false; // preserve error offset.
		internal_null_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}

	bool Bool(bool& b)
	{
		return Bool_CB(internal_simple_setter{b}, {});
	}
	template<class Callback>
	bool Bool_CB(Callback cb, bool)
	{
		if(error) return false; // preserve error offset.
		internal_bool_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool Int(int& i)
	{
		return Int_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	bool Int_CB(Callback cb, int)
	{
		if(error) return false; // preserve error offset.
		internal_int_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool Uint(unsigned& u)
	{
		return Uint_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint_CB(Callback cb, unsigned)
	{
		if(error) return false; // preserve error offset.
		internal_uint_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool Int64(int64_t& i)
	{
		return Int64_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	bool Int64_CB(Callback cb, int64_t)
	{
		if(error) return false; // preserve error offset.
		internal_int64_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool Uint64(uint64_t& u)
	{
		return Uint64_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint64_CB(Callback cb, uint64_t)
	{
		if(error) return false; // preserve error offset.
		internal_uint64_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	bool Uint16(uint16_t& u)
	{
		return Uint16_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint16_CB(Callback cb, uint16_t)
	{
		if(error) return false; // preserve error offset.
		// promote to uint
		internal_uint_promote_json_handler<uint16_t, Callback> handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool Uint8(uint8_t& u)
	{
		return Uint8_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint8_CB(Callback cb, uint8_t)
	{
		if(error) return false; // preserve error offset.
		// promote to uint
		internal_uint_promote_json_handler<uint8_t, Callback> handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool Double(double& d)
	{
		return Double_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	bool Double_CB(Callback cb, double)
	{
		if(error) return false; // preserve error offset.
		// internal_finite_double_wrapper will check std::isfinite
		internal_double_json_handler handler(internal_finite_double_wrapper<Callback, double>{cb});
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	// float will promote to double, there shouldn't be a problem.
	bool Float(float& d)
	{
		return Double_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	bool Float_CB(Callback cb, float)
	{
		// promote to double
		return Double_CB(cb, {});
	}
	bool String(std::string& str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return String_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	bool String_CB(
		Callback cb, std::string_view, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		if(error) return false; // preserve error offset.
		internal_string_json_handler handler{cb, max_size};
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	// json requires valid utf8, and binary wont work.
	bool Data(std::string& str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return Data_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	bool Data_CB(
		Callback cb, std::string_view, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		if(error) return false; // preserve error offset.
		internal_data_json_handler handler(cb, max_size);
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}

	bool Key(std::string_view str)
	{
		if(error) return false; // preserve error offset.
		internal_key_json_handler handler(str.data(), str.size());
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}

	bool StartObject()
	{
		if(error) return false; // preserve error offset.
		internal_startobject_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool EndObject()
	{
		if(error) return false; // preserve error offset.
		internal_endobject_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool StartArray()
	{
		if(error) return false; // preserve error offset.
		internal_startarray_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
	bool EndArray()
	{
		if(error) return false; // preserve error offset.
		internal_endarray_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("read after complete: %s\n", __func__);
			error = true;
			return false;
		}
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
			return false;
		}
		return true;
	}
};

// you could set JsonOutput to rj::StringBuffer
template<class JsonOutput, class JsonFormat = rj::PrettyWriter<JsonOutput>>
class JsonWriter
{
public:
	JsonFormat writer;

	enum
	{
		IsReader = 0
	};

	explicit JsonWriter(JsonOutput& output)
	: writer(output)
	{
	}

	bool is_complete() const
	{
		return writer.IsComplete();
	}

	bool Null()
	{
		return writer.Null();
	}

	bool Bool(bool b)
	{
		return writer.Bool(b);
	}
	template<class Callback>
	bool Bool_CB(Callback, bool b)
	{
		return Bool(b);
	}
	bool Int(int i)
	{
		return writer.Int(i);
	}
	template<class Callback>
	bool Int_CB(Callback, int i)
	{
		return Int(i);
	}
	bool Uint(unsigned u)
	{
		return writer.Uint(u);
	}
	template<class Callback>
	bool Uint_CB(Callback, unsigned u)
	{
		return Uint(u);
	}
	bool Int64(int64_t i)
	{
		return writer.Int64(i);
	}
	template<class Callback>
	bool Int64_CB(Callback, int64_t i)
	{
		return Int64(i);
	}
	bool Uint64(uint64_t u)
	{
		return writer.Uint64(u);
	}
	template<class Callback>
	bool Uint64_CB(Callback, uint64_t u)
	{
		return Uint64(u);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	bool Uint16(uint16_t u)
	{
		return writer.Uint(u);
	}
	template<class Callback>
	bool Uint16_CB(Callback, uint16_t u)
	{
		return Uint16(u);
	}
	bool Uint8(uint8_t u)
	{
		return writer.Uint(u);
	}
	template<class Callback>
	bool Uint8_CB(Callback, uint8_t u)
	{
		return Uint8(u);
	}
	bool Double(double d)
	{
		if(!std::isfinite(d))
		{
			serrf("failed to write double: %f\n", d);
			ASSERT(std::isfinite(d) && "failed to write double");
			return false;
		}
		return writer.Double(d);
	}
	template<class Callback>
	bool Double_CB(Callback, double d)
	{
		return Double(d);
	}
	// float will promote to double.
	bool Float(float d)
	{
		if(!std::isfinite(d))
		{
			serrf("failed to write float: %f\n", d);
			ASSERT(std::isfinite(d) && "failed to write float");
			return false;
		}
		return Double(d);
	}
	template<class Callback>
	bool Float_CB(Callback, float d)
	{
		return Float(d);
	}
	bool String(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		if(str.size() > max_size)
		{
			// not much information, but we are writing this
			// so you should pull out a debugger and check it yourself.
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			ASSERT(str.size() <= max_size);
			Null();
			return false;
		}
		return writer.String(str.data(), str.size());
	}
	template<class Callback>
	bool String_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return String(str, max_size);
	}
	// json requires valid utf8, and binary wont work.
	bool Data(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		if(str.size() > max_size)
		{
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			ASSERT(str.size() <= max_size);
			Null();
			return false;
		}
		std::string tmp = base64_encode(str.data(), str.size());
		return writer.String(tmp.data(), tmp.size());
	}
	template<class Callback>
	bool Data_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return Data(str, max_size);
	}

	bool Key(std::string_view str)
	{
		return writer.Key(str.data(), str.size());
	}

	bool StartObject()
	{
		return writer.StartObject();
	}
	bool EndObject()
	{
		return writer.EndObject();
	}
	bool StartArray()
	{
		return writer.StartArray();
	}
	bool EndArray()
	{
		return writer.EndArray();
	}
};

template<class StreamReader>
class BinaryReader
{
public:
	StreamReader& reader;
	bool error = false;

	enum
	{
		IsReader = 1
	};

	explicit BinaryReader(StreamReader& reader_)
	: reader(reader_)
	{
	}

	bool good() const
	{
		return !error;
	}

	bool Null()
	{
		return !error;
	}

	bool Bool(bool& b)
	{
		return Int_CB(internal_simple_setter{b}, {});
	}
	template<class Callback>
	bool Bool_CB(Callback cb, bool)
	{
		if(error) return false;
		bool b = reader.Take();
		if(!reader.good() || !cb(b))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Int(int& i)
	{
		return Int_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	bool Int_CB(Callback cb, int)
	{
		if(error) return false;
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		if(!reader.good() || !cb(static_cast<int32_t>(tmp)))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Uint(unsigned& u)
	{
		return Uint_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint_CB(Callback cb, unsigned)
	{
		if(error) return false;
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		if(!reader.good() || !cb(tmp))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Int64(int64_t& i)
	{
		return Int64_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	bool Int64_CB(Callback cb, int64_t)
	{
		if(error) return false;
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		if(!reader.good() || !cb(static_cast<int64_t>(tmp)))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Uint64(uint64_t& u)
	{
		return Uint64_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint64_CB(Callback cb, uint64_t)
	{
		if(error) return false;
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		if(!reader.good() || !cb(tmp))
		{
			error = true;
			return false;
		}
		return !error;
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	bool Uint16(uint16_t& u)
	{
		return Uint16_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint16_CB(Callback cb, uint16_t)
	{
		if(error) return false;
		uint16_t tmp = static_cast<uint8_t>(reader.Take()) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		if(!reader.good() || !cb(tmp))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Uint8(uint8_t& u)
	{
		return Uint8_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	bool Uint8_CB(Callback cb, uint8_t)
	{
		if(error) return false;
		uint8_t tmp = reader.Take();
		if(!reader.good() || !cb(tmp))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Double(double& d)
	{
		return Double_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	bool Double_CB(Callback cb, double)
	{
		uint64_t tmp;
		if(!Uint64(tmp))
		{
			return false;
		}

		// this feels wrong, but internal_finite_double_wrapper
		// will check std::finite, which should make it ok most of the time :)
		// double d = *reinterpret_cast<double*>(&tmp);
		// get around -Wstrict-aliasing warning
		double d;
		memcpy(&d, &tmp, sizeof(d));

		if(!reader.good() || !internal_finite_double_wrapper<Callback, double>{cb}(d))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool Float(float& d)
	{
		return Float_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	bool Float_CB(Callback cb, float)
	{
		uint32_t tmp;
		if(!Uint(tmp))
		{
			return false;
		}

		// this feels wrong, but internal_finite_double_wrapper
		// will check std::finite, which should make it ok most of the time :)
		// float d = *reinterpret_cast<float*>(&tmp);
		// get around -Wstrict-aliasing warning
		float d;
		memcpy(&d, &tmp, sizeof(d));

		if(!reader.good() || !internal_finite_double_wrapper<Callback, float>{cb}(d))
		{
			error = true;
			return false;
		}
		return !error;
	}
	bool String(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return String_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	bool String_CB(
		Callback cb, std::string_view, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		// this is a huge buffer, but windows should have a 1 mb large stack so 65kb isn't much.
		// I'm not very happy with this, I need a fread function but too lazy to benchmark.
		char buf[std::numeric_limits<uint16_t>::max()];
		uint16_t size;

		if(!Uint16(size))
		{
			return false;
		}
		if(size > max_size)
		{
			error = true;
			serrf("string too large, max: %zu result: %u\n", max_size, size);
			return false;
		}

		for(size_t i = 0; i < size; ++i)
		{
			buf[i] = reader.Take();
		}

		if(!reader.good() || !cb(buf, size))
		{
			error = true;
			return false;
		}
		return true;
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String_CB(cb, {}, max_size);
	}

	bool Key(std::string_view)
	{
		return !error;
	}
	bool StartObject()
	{
		return !error;
	}
	bool EndObject()
	{
		return !error;
	}
	bool StartArray()
	{
		return !error;
	}
	bool EndArray()
	{
		return !error;
	}
};

template<class WriteStream>
class BinaryWriter
{
public:
	WriteStream& output;

	enum
	{
		IsReader = 0
	};

	explicit BinaryWriter(WriteStream& output_)
	: output(output_)
	{
	}

	bool Null()
	{
		return output.good();
	}

	bool Bool(bool b)
	{
		output.Put(b);
		return output.good();
	}
	template<class Callback>
	bool Bool_CB(Callback, bool b)
	{
		return Bool(b);
	}
	bool Int(int i)
	{
		output.Put(static_cast<char>(i >> 24));
		output.Put(static_cast<char>(i >> 16));
		output.Put(static_cast<char>(i >> 8));
		output.Put(static_cast<char>(i));
		return output.good();
	}
	template<class Callback>
	bool Int_CB(Callback, int i)
	{
		return Int(i);
	}
	bool Uint(unsigned u)
	{
		output.Put(static_cast<char>(u >> 24));
		output.Put(static_cast<char>(u >> 16));
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
		return output.good();
	}
	template<class Callback>
	bool Uint_CB(Callback, unsigned u)
	{
		return Uint(u);
	}
	bool Int64(int64_t i)
	{
		output.Put(static_cast<char>(i >> 56));
		output.Put(static_cast<char>(i >> 48));
		output.Put(static_cast<char>(i >> 40));
		output.Put(static_cast<char>(i >> 32));
		output.Put(static_cast<char>(i >> 24));
		output.Put(static_cast<char>(i >> 16));
		output.Put(static_cast<char>(i >> 8));
		output.Put(static_cast<char>(i));
		return output.good();
	}
	template<class Callback>
	bool Int64_CB(Callback, int64_t i)
	{
		return Int64(i);
	}
	bool Uint64(uint64_t u)
	{
		output.Put(static_cast<char>(u >> 56));
		output.Put(static_cast<char>(u >> 48));
		output.Put(static_cast<char>(u >> 40));
		output.Put(static_cast<char>(u >> 32));
		output.Put(static_cast<char>(u >> 24));
		output.Put(static_cast<char>(u >> 16));
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
		return output.good();
	}
	template<class Callback>
	bool Uint64_CB(Callback, uint64_t u)
	{
		return Uint64(u);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	bool Uint16(uint16_t u)
	{
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
		return output.good();
	}
	template<class Callback>
	bool Uint16_CB(Callback, uint16_t u)
	{
		return Uint16(u);
	}
	bool Uint8(uint8_t u)
	{
		output.Put(static_cast<char>(u));
		return output.good();
	}
	template<class Callback>
	bool Uint8_CB(Callback, uint8_t u)
	{
		return Uint8(u);
	}
	bool Double(double d)
	{
		if(!std::isfinite(d))
		{
			serrf("failed to write double: %f\n", d);
			ASSERT(std::isfinite(d) && "failed to write double");
			return false;
		}
		// uint64_t fhold = *reinterpret_cast<uint64_t*>(&d);
		// get around -Wstrict-aliasing warning
		uint64_t fhold;
		memcpy(&fhold, &d, sizeof(fhold));

		output.Put(static_cast<char>(fhold >> 56));
		output.Put(static_cast<char>(fhold >> 48));
		output.Put(static_cast<char>(fhold >> 40));
		output.Put(static_cast<char>(fhold >> 32));
		output.Put(static_cast<char>(fhold >> 24));
		output.Put(static_cast<char>(fhold >> 16));
		output.Put(static_cast<char>(fhold >> 8));
		output.Put(static_cast<char>(fhold));
		return output.good();
	}
	template<class Callback>
	bool Double_CB(Callback, double d)
	{
		return Double(d);
	}
	// float will promote to double.
	bool Float(float d)
	{
		if(!std::isfinite(d))
		{
			serrf("failed to write float: %f\n", d);
			ASSERT(std::isfinite(d) && "failed to write float");
			return false;
		}
		// uint32_t fhold = *reinterpret_cast<uint32_t*>(&d);
		// get around -Wstrict-aliasing warning
		uint32_t fhold;
		memcpy(&fhold, &d, sizeof(fhold));
		output.Put(static_cast<char>(fhold >> 24));
		output.Put(static_cast<char>(fhold >> 16));
		output.Put(static_cast<char>(fhold >> 8));
		output.Put(static_cast<char>(fhold));
		return output.good();
	}
	template<class Callback>
	bool Float_CB(Callback, float d)
	{
		return Float(d);
	}
	bool String(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		if(str.size() > max_size)
		{
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			ASSERT(str.size() <= max_size);
			return false;
		}
		if(!Uint16(str.size()))
		{
			return false;
		}
		for(char c : str)
		{
			output.Put(c);
		}
		return output.good();
	}
	template<class Callback>
	bool String_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return String(str, max_size);
	}
	// json requires valid utf8, and binary wont work.
	bool Data(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return String(str, max_size);
	}
	template<class Callback>
	bool Data_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		return String(str, max_size);
	}

	bool Key(std::string_view)
	{
		return output.good();
	}

	bool StartObject()
	{
		return output.good();
	}
	bool EndObject()
	{
		return output.good();
	}
	bool StartArray()
	{
		return output.good();
	}
	bool EndArray()
	{
		return output.good();
	}
};

// the problem with rj::StringStream is that it won't work with BinaryReader,
// because rj::StringStream doesn't check for overrun because NULL is used for EOF
struct KsonMemoryStream
{
	typedef char Ch;

	const char* src; //!< Current read position.
	const char* head; //!< Original head of the string.
	const char* end;
	// I could replace this with something like end = NULL,
	// but I don't care that much about micro optimization.
	bool error;

	explicit KsonMemoryStream(const char* src_, const char* end_)
	: src(src_)
	, head(src_)
	, end(end_)
	, error(false)
	{
	}

	char Peek() const
	{
		return (src >= end ? '\0' : *src);
	}
	char Take()
	{
		// the comma operator is very important
		return (src >= end ? (error = true, '\0') : *src++);
	}
	size_t Tell() const
	{
		return src - head;
	}

	char* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	void Put(char)
	{
		ASSERT(false);
	}
	void Flush()
	{
		ASSERT(false);
	}
	size_t PutEnd(char*)
	{
		ASSERT(false);
		return 0;
	}

	bool good() const
	{
		return !error;
	}
};

// I just need the error function
struct KsonStringBuffer : rj::StringBuffer
{
	explicit KsonStringBuffer(size_t capacity = kDefaultCapacity)
	: rj::StringBuffer(0, capacity)
	{
	}
	static const size_t kDefaultCapacity = 256;

	bool good() const
	{
		return true;
	}
};

// the callback signature is <size_t(char* buffer, size_t read_num)> returns bytes read.
// This is copy pasted from rapidjson::FileReadStream, but modified for use by RWops.
template<class Callback>
class KsonCB_ReadStream
{
public:
	typedef char Ch; //!< Character type (byte).

	KsonCB_ReadStream(Callback cb_, char* buffer, size_t bufferSize)
	: cb(cb_)
	, buffer_(buffer)
	, bufferSize_(bufferSize)
	, bufferLast_(0)
	, current_(buffer_)
	, readCount_(0)
	, count_(0)
	, eof_(false)
	, error_(false)
	{
		Read();
	}

	Ch Peek() const
	{
		return *current_;
	}
	Ch Take()
	{
		Ch c = *current_;
		Read();
		return c;
	}
	size_t Tell() const
	{
		return count_ + (current_ - buffer_);
	}

	// Not implemented
	void Put(Ch)
	{
		ASSERT(false);
	}
	void Flush()
	{
		ASSERT(false);
	}
	Ch* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	size_t PutEnd(Ch*)
	{
		ASSERT(false);
		return 0;
	}

	bool good() const
	{
		return !error_;
	}

private:
	void Read()
	{
		if(current_ < bufferLast_)
		{
			++current_;
		}
		else if(!eof_)
		{
			count_ += readCount_;
			readCount_ = cb(buffer_, bufferSize_);
			bufferLast_ = buffer_ + readCount_ - 1;
			current_ = buffer_;

			if(readCount_ < bufferSize_)
			{
				buffer_[readCount_] = '\0';
				++bufferLast_;
				eof_ = true;
			}
		}
		else
		{
			error_ = true;
		}
	}

	Callback cb;
	Ch* buffer_;
	size_t bufferSize_;
	Ch* bufferLast_;
	Ch* current_;
	size_t readCount_;
	size_t count_; //!< Number of characters read
	bool eof_;
	bool error_;
};

// the callback signature is <size_t(char* buffer, size_t write_num)> returns bytes written.
// You might want to flush if you want RWops::tell to work.
// this is copy pasted from rapidjson::FileWriteStream
template<class Callback>
class KsonCB_WriteStream
{
public:
	typedef char Ch; //!< Character type. Only support char.

	KsonCB_WriteStream(Callback cb_, char* buffer, size_t bufferSize)
	: cb(cb_)
	, buffer_(buffer)
	, bufferEnd_(buffer + bufferSize)
	, current_(buffer_)
	, error(false)
	{
	}

	void Put(char c)
	{
		if(error) return;
		if(current_ >= bufferEnd_) Flush();
		*current_++ = c;
	}

	void Flush()
	{
		if(current_ != buffer_)
		{
			size_t result = cb(buffer_, current_ - buffer_);
			if(result < static_cast<size_t>(current_ - buffer_))
			{
				error = true;
			}
			current_ = buffer_;
		}
	}

	// Not implemented
	char Peek() const
	{
		ASSERT(false);
		return 0;
	}
	char Take()
	{
		ASSERT(false);
		return 0;
	}
	size_t Tell() const
	{
		ASSERT(false);
		return 0;
	}
	char* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	size_t PutEnd(char*)
	{
		ASSERT(false);
		return 0;
	}

	bool good() const
	{
		return !error;
	}

private:
	Callback cb;
	char* buffer_;
	char* bufferEnd_;
	char* current_;
	bool error;
};

template<class Reader, size_t max_line_length = 1024>
// NOLINTNEXTLINE(readability-function-cognitive-complexity)
void print_json_error(Reader& reader, size_t offset)
{
	char buffer[max_line_length];
	size_t line_n = 0;
	size_t count = 0;
	size_t line_start = 0;
	char* pos = buffer;
	char* end = buffer + max_line_length;
	while(true)
	{
		if(pos < end)
		{
			*pos = reader.Take();
			++count;
			if(*pos == '\n')
			{
				if(offset < count)
				{
					break;
				}
				++line_n;
				pos = buffer;
				line_start = count;
			}
			else if(*pos == '\0')
			{
				break;
			}
			else
				++pos;
		}
		else
		{
			char c = reader.Take();
			++count;
			if(c == '\n')
			{
				if(offset < count)
				{
					break;
				}
				++line_n;
				pos = buffer;
				line_start = count;
			}
			else if(c == '\0')
			{
				break;
			}
		}
	}
	if(offset <= count)
	{
		// clear any control values (mainly for windows \r\n)
		char* line_end = std::remove_if(buffer, pos, [](unsigned char _1) {
			return _1 != '\n' && _1 != '\t' && (_1 < 32 || _1 == 127);
		});

		*line_end = '\0';

		// tabs to spaces because it makes the column index clearer.
		// std::replace(buffer, line_end, '\t', ' ');

		serrf(
			"Line: %zu\n"
			"Col: %zu\n"
			">>>%s\n",
			line_n + 1,
			offset - line_start + 1,
			buffer);
	}
	else
	{
		// TODO (dootsie): I didn't test this enough
		ASSERT(false && "unreachable");
	}
}

struct internal_rwops_read_callback
{
	RWops* file;
	size_t operator()(char* memory, size_t read_num) const
	{
		return file->read(memory, 1, read_num);
	}
};

struct internal_rwops_write_callback
{
	RWops* file;
	size_t operator()(char* memory, size_t write_num) const
	{
		return file->write(memory, 1, write_num);
	}
};

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_json_memory(
	Callback cb, const char* file_memory, size_t file_size, const char* info = "<unspecified>")
{
	ASSERT(file_memory != NULL);
	ASSERT(info != NULL);

	KsonMemoryStream stream(file_memory, file_memory + file_size);

	JsonReader ar(stream);

	bool cb_return = cb(ar);

	if(ar.reader.HasParseError())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: %s\n"
			"Offset: %zu\n",
			info,
			GetParseError_En(ar.reader.GetParseErrorCode()),
			ar.reader.GetErrorOffset());
		// rewind the stream
		stream = KsonMemoryStream(file_memory, file_memory + file_size);
		print_json_error(stream, ar.reader.GetErrorOffset());

		return false;
	}

	// if there was an error expected to be printed
	if(!ar.good())
	{
		size_t offset = stream.Tell();
		serrf(
			"Failed to parse json: `%s`\n"
			"Offset: %zu\n",
			info,
			offset);
		// rewind the stream
		stream = KsonMemoryStream(file_memory, file_memory + file_size);
		print_json_error(stream, ar.reader.GetErrorOffset());
		return false;
	}

	if(!cb_return)
	{
		serrf("Failed to parse json: `%s`\n", info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: incomplete json\n",
			info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}
	return true;
}

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_json_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char read_buffer[1000];
	KsonCB_ReadStream stream(internal_rwops_read_callback{file}, read_buffer, sizeof(read_buffer));

	JsonReader ar(stream);

	bool cb_return = cb(ar);

	if(ar.reader.HasParseError())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: %s\n"
			"Offset: %zu\n",
			info,
			GetParseError_En(ar.reader.GetParseErrorCode()),
			ar.reader.GetErrorOffset());

		// rewind the stream
		if(file->seek(0, SEEK_SET) >= 0)
		{
			// reset the stream.
			stream = KsonCB_ReadStream(
				internal_rwops_read_callback{file}, read_buffer, sizeof(read_buffer));
			print_json_error(stream, ar.reader.GetErrorOffset());
		}
		return false;
	}

	// if there was an error expected to be printed
	if(!ar.good() || !cb_return)
	{
		size_t offset = stream.Tell();
		serrf(
			"Failed to parse json: `%s`\n"
			"Offset: %zu\n",
			info,
			offset);
		// rewind the stream
		if(file->seek(0, SEEK_SET) >= 0)
		{
			// reset the stream.
			stream = KsonCB_ReadStream(
				internal_rwops_read_callback{file}, read_buffer, sizeof(read_buffer));
			print_json_error(stream, offset);
		}
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: incomplete json\n",
			info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}
	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_json_memory(Callback cb, KsonStringBuffer& sb, const char* info = "<unspecified>")
{
	ASSERT(info != NULL);
	JsonWriter ar(sb);

	bool cb_return = cb(ar);

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write json: `%s`\n", info);
		serrf("Stream size: %zu\n", sb.GetSize());
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to write json: `%s`\n"
			"Error: failed to write a complete json file\n",
			info);
		serrf("Stream size: %zu\n", sb.GetSize());
		return false;
	}
	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_json_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char write_buffer[1000];
	KsonCB_WriteStream stream(
		internal_rwops_write_callback{file}, write_buffer, sizeof(write_buffer));

	JsonWriter ar(stream);

	bool cb_return = cb(ar);

	// file->tell() will not work without this.
	stream.Flush();

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write json: `%s`\n", info);
		serrf("Stream size: `%d`\n", file->tell());
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to write json: `%s`\n"
			"Error: failed to write a complete json file\n",
			info);
		serrf("Stream size: `%d`\n", file->tell());
		return false;
	}
	return true;
}

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_binary_memory(
	Callback cb, const char* file_memory, size_t file_size, const char* info = "<unspecified>")
{
	ASSERT(file_memory != NULL);
	ASSERT(info != NULL);

	KsonMemoryStream stream(file_memory, file_memory + file_size);

	BinaryReader ar(stream);

	bool cb_return = cb(ar);

	if(!ar.good() || !cb_return)
	{
		serrf("Failed to parse binary: `%s`\n", info);
		serrf("Stream size: %zu\n", file_size);
		serrf("Cursor: %zu\n", stream.Tell());
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", file_size);
		serrf("Cursor: %zu\n", stream.Tell());
		return false;
	}

	// Did we read every byte?
	if(stream.Tell() != file_size)
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: mismatching file end, size: %zu cursor: %zu\n",
			info,
			file_size,
			stream.Tell());
		return -1;
	}

	return true;
}

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_binary_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char read_buffer[1000];
	KsonCB_ReadStream stream(internal_rwops_read_callback{file}, read_buffer, sizeof(read_buffer));

	BinaryReader ar(stream);

	bool cb_return = cb(ar);

	// if there was an error expected to be printed
	if(!ar.good() || !cb_return)
	{
		serrf("Failed to parse binary: `%s`\n", info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}

	// did we read every byte?
	int cursor = file->tell();
	file->seek(0, SEEK_END);
	int end = file->tell();
	if(cursor != end || cursor == -1)
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: mismatching file end, size: %d cursor: %d\n",
			info,
			end,
			cursor);
		return -1;
	}

	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_binary_memory(Callback cb, KsonStringBuffer& sb, const char* info = "<unspecified>")
{
	ASSERT(info != NULL);
	BinaryWriter ar(sb);

	bool cb_return = cb(ar);

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write binary: `%s`\n", info);
		serrf("Stream size: %zu\n", sb.GetSize());
		return false;
	}
	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_binary_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char write_buffer[1000];
	KsonCB_WriteStream stream(
		internal_rwops_write_callback{file}, write_buffer, sizeof(write_buffer));

	BinaryWriter ar(stream);

	bool cb_return = cb(ar);

	// file->tell() will not work without this.
	stream.Flush();

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write binary: `%s`\n", info);
		serrf("Stream size: %d\n", file->tell());
		return false;
	}
	return true;
}

// convenience callback helper
template<class T>
struct kson_min_max_cb
{
	T& value;
	T min_value;
	T max_value;
	explicit kson_min_max_cb(T& value_, T min_value_, T max_value_)
	: value(value_)
	, min_value(min_value_)
	, max_value(max_value_)
	{
		ASSERT(min_value <= max_value);
	}
	bool operator()(T result)
	{
		if(result < min_value)
		{
			// printf + generics don't mix up well, better use a stringstream.
			std::ostringstream oss;
			oss << "error result too small: " << result << " < min: " << min_value;
			serrf("%s\n", oss.str().c_str());
			return false;
		}
		if(result > max_value)
		{
			std::ostringstream oss;
			oss << "error result too big: " << result << " > max: " << max_value;
			serrf("%s\n", oss.str().c_str());
			return false;
		}
		value = result;
		return true;
	}
};
