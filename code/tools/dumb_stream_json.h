#pragma once

// This is a JSON API for a restrictive style of JSON that supports binary serialization.
// I want to call this KSON to distinguish itself as NOT json, but it's just JSON+Binary.
// The most important feature is the symetric read / write system using templates.
// Used when the file is exclusively generated by the program, not a human.
// This was inspired by a example called "archiver" in the rapidjson examples.
// Limitations:
// Variables must be ordered, no variable can be missing, no variable can be skipped over.
// Keys, objects, arrays, are stubbed away in the binary serializer.
// An annoying limitation is that dynamic sized arrays requires you to specifiy
// The size of an array ahead of the data you load (like a pascal string).
// Arrays require you to also check the IsWriter flag to properly work with dynamic arrays.
// Note:
// Performance is not a goal for the Binary format, because rapidjson is surprisingly fast,
// (note that rapidjson DOM is on equal performance as the binary format for my simple tests)
// But the benefit is the lack of care needed with the length of key strings in JSON,
// So you can have descriptive names of every variable without a care,
// and even group up variables in redundant object scopes.
// To insert comments you can use "key":null, useful for type ID's.

// TODO:
//-the base64 serializer needs tidying
//-even though it's completely redundant, maybe I should have a NDEBUG optimized out
// stack that checks that all Key Start Stop Array Object are matched correctly in BinaryWriter
// but Just testing Json should detect any malformed Json
// (-DNDEBUG will remove rapidjson checks for the writer but it will quickly segfault)
//-If you write a string/data that is longer than the max size, you will assert.
// maybe it would be nice if I used std::source_location and print that into serrf,
// but a backtrace from a debugger has much more information (include a trace in the message?),
// but this error SHOULD only be a programmer error (why was the string that long?)
//-The example is overcomplicated, maybe write a convenience wrapper that "just works"?

#include "SDL_stdinc.h"
#define RAPIDJSON_ASSERT ASSERT
#define RAPIDJSON_HAS_STDSTRING 1

//#include "rapidjson/rapidjson.h"
#include <cstdint>
#include <rapidjson/writer.h>

#include <limits>

//#include <rapidjson/rapidjson.h>
#include <rapidjson/reader.h>
// you generally always want to check errors.
#include <rapidjson/error/en.h>

namespace rj = rapidjson;

// I got this from stack overflow https://stackoverflow.com/a/41094722
static const int B64index[256] = {
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
	0,	62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,	0,	0,	0,	0,
	0,	0,	0,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10, 11, 12, 13, 14, 15, 16, 17, 18,
	19, 20, 21, 22, 23, 24, 25, 0,	0,	0,	0,	63, 0,	26, 27, 28, 29, 30, 31, 32, 33,
	34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};

// NOLINTBEGIN

inline std::string b64decode(const void* data, const size_t len)
{
	unsigned char* p = (unsigned char*)data;
	int pad = len > 0 && (len % 4 || p[len - 1] == '=');
	const size_t L = ((len + 3) / 4 - pad) * 4;
	std::string str(L / 4 * 3 + pad, '\0');

	for(size_t i = 0, j = 0; i < L; i += 4)
	{
		int n = B64index[p[i]] << 18 | B64index[p[i + 1]] << 12 | B64index[p[i + 2]] << 6 |
				B64index[p[i + 3]];
		str[j++] = n >> 16;
		str[j++] = n >> 8 & 0xFF;
		str[j++] = n & 0xFF;
	}
	if(pad)
	{
		int n = B64index[p[L]] << 18 | B64index[p[L + 1]] << 12;
		str[str.size() - 1] = n >> 16;

		if(len > L + 2 && p[L + 2] != '=')
		{
			n |= B64index[p[L + 2]] << 6;
			str.push_back(n >> 8 & 0xFF);
		}
	}
	return str;
}

/*
 * Base64 encoding/decoding (RFC1341)
 * Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi>
 *
 * This software may be distributed under the terms of the BSD license.
 * See README for more details.
 */

// 2016-12-12 - Gaspard Petit : Slightly modified to return a std::string
// instead of a buffer allocated with malloc.

static const unsigned char base64_table[65] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
/**
 * base64_encode - Base64 encode
 * @src: Data to be encoded
 * @len: Length of the data to be encoded
 * @out_len: Pointer to output length variable, or %NULL if not used
 * Returns: Allocated buffer of out_len bytes of encoded data,
 * or empty string on failure
 */
inline std::string base64_encode(const void* src, size_t len)
{
	unsigned char *out, *pos;
	const unsigned char *end, *in;

	size_t olen;

	olen = 4 * ((len + 2) / 3); /* 3-byte blocks to 4-byte */

	if(olen < len) return std::string(); /* integer overflow */

	std::string outStr;
	outStr.resize(olen);
	out = (unsigned char*)&outStr[0];

	end = (unsigned char*)src + len;
	in = (unsigned char*)src;
	pos = out;
	while(end - in >= 3)
	{
		*pos++ = base64_table[in[0] >> 2];
		*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		*pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
		*pos++ = base64_table[in[2] & 0x3f];
		in += 3;
	}

	if(end - in)
	{
		*pos++ = base64_table[in[0] >> 2];
		if(end - in == 1)
		{
			*pos++ = base64_table[(in[0] & 0x03) << 4];
			*pos++ = '=';
		}
		else
		{
			*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
			*pos++ = base64_table[(in[1] & 0x0f) << 2];
		}
		*pos++ = '=';
	}

	return outStr;
}

// NOLINTEND

template<class Callback>
class MyBoolHandler : public rj::BaseReaderHandler<rj::UTF8<>, MyBoolHandler<Callback>>
{
  public:
	Callback call;

	explicit MyBoolHandler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		// TODO (dootsie): I could easily create my own rj::BaseReaderHandler
		// which will include the result that was not expected, because this is vague.
		serr("expected bool\n");
		return false;
	}
	bool Bool(bool b)
	{
		return call(b);
	}
};

template<class Callback>
class internal_int_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_int_json_reader<Callback>>
{
  public:
	Callback call;

	explicit internal_int_json_reader(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected int\n");
		return false;
	}
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		if(u <= std::numeric_limits<int>::max())
		{
			return call(u);
		}
		serrf("number too large, max: %d, result: %u\n", std::numeric_limits<int>::max(), u);
		return false;
	}
};

template<class Callback>
class internal_uint_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint_json_reader<Callback>>
{
  public:
	Callback call;

	explicit internal_uint_json_reader(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected uint\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
};

template<class Callback>
class internal_int64_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_int64_json_reader<Callback>>
{
  public:
	Callback call;

	explicit internal_int64_json_reader(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected int64\n");
		return false;
	}
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
	bool Int64(int64_t i)
	{
		return call(i);
	}
	bool Uint64(uint64_t u)
	{
		if(u <= std::numeric_limits<int64_t>::max())
		{
			return call(u);
		}
		serrf(
			"number too large, max: %" PRIi64 ", result: %" PRIu64 "\n",
			std::numeric_limits<int64_t>::max(),
			u);
		return false;
	}
};

template<class Callback>
class internal_uint64_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint64_json_reader<Callback>>
{
  public:
	Callback call;

	explicit internal_uint64_json_reader(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected uint64\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
	bool Uint64(uint64_t u)
	{
		return call(u);
	}
};

template<class Callback>
class internal_double_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_double_json_reader<Callback>>
{
  public:
	Callback call;

	explicit internal_double_json_reader(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected double\n");
		return false;
	}
// I am tempted to disable this, just for strictness.
#if 1
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
#endif
	bool Double(double d)
	{
		return call(d);
	}
};

template<class T, class Callback>
class internal_uint_promote_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint_promote_json_reader<T, Callback>>
{
  public:
	Callback call;

	explicit internal_uint_promote_json_reader(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected unsigned number\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		if(u <= std::numeric_limits<T>::max())
		{
			return call(u);
		}
		serrf(
			"number too large, max: %zu, result: %u\n",
			static_cast<size_t>(std::numeric_limits<T>::max()),
			u);
		return false;
	}
};

template<class Callback>
class internal_string_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_string_json_reader<Callback>>
{
  public:
	Callback call;
	size_t max_size;

	explicit internal_string_json_reader(Callback cb, size_t max_size_)
	: call(cb)
	, max_size(max_size_)
	{
	}
	bool Default()
	{
		serr("expected string\n");
		return false;
	}
	bool String(const char* str, rj::SizeType length, bool)
	{
		if(length <= max_size)
		{
			return call(str, length);
		}
		serrf("string too large, max: %zu result: %zu\n", max_size, static_cast<size_t>(length));
		return false;
	}
};

template<class Callback>
class internal_data_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_data_json_reader<Callback>>
{
  public:
	Callback call;
	size_t max_size;

	explicit internal_data_json_reader(Callback cb, size_t max_size_)
	: call(cb)
	, max_size(max_size_)
	{
	}
	bool Default()
	{
		serr("expected data\n");
		return false;
	}
	bool String(const char* str, rj::SizeType length, bool)
	{
		std::string tmp = b64decode(str, length);
		if(tmp.size() <= max_size)
		{
			return call(tmp.data(), tmp.size());
		}
		serrf("string too large, max: %zu result: %zu\n", max_size, tmp.size());
		return false;
	}
};

template<size_t size>
class internal_key_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_key_json_reader<size>>
{
  public:
	const char (&s)[size];

	explicit internal_key_json_reader(const char (&s_)[size])
	: s(s_)
	{
	}
	bool Default()
	{
		serrf("expected key type: \"%s\"\n", s);
		return false;
	}
	bool Key(const char* str, rj::SizeType length, bool)
	{
		if(length == size - 1 && strncmp(str, s, size - 1) == 0)
		{
			return true;
		}
		serrf("mismatching keys expected: %s, result: %s\n", str, s);
		return false;
	}
};

class internal_startobject_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_startobject_json_reader>
{
  public:
	bool Default()
	{
		serr("expected '{'\n");
		return false;
	}
	bool StartObject()
	{
		return true;
	}
};

class internal_endobject_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_endobject_json_reader>
{
  public:
	bool Default()
	{
		serr("expected '}'\n");
		return false;
	}
	bool EndObject(rj::SizeType)
	{
		return true;
	}
};

class internal_startarray_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_startarray_json_reader>
{
  public:
	bool Default()
	{
		serr("expected '['\n");
		return false;
	}
	bool StartArray()
	{
		return true;
	}
};

class internal_endarray_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_endarray_json_reader>
{
  public:
	bool Default()
	{
		serr("expected ']'\n");
		return false;
	}
	bool EndArray(rj::SizeType)
	{
		return true;
	}
};

class internal_null_json_reader
: public rj::BaseReaderHandler<rj::UTF8<>, internal_null_json_reader>
{
  public:
	bool Default()
	{
		serr("expected null\n");
		return false;
	}
	bool Null()
	{
		return true;
	}
};

template<class T>
struct internal_simple_setter
{
	T& b;
	explicit internal_simple_setter(T& b_)
	: b(b_)
	{
	}
	bool operator()(T b_)
	{
		b = b_;
		return true;
	}
};

struct internal_string_setter
{
	std::string& str;
	bool operator()(const char* str_, rj::SizeType length_)
	{
		str = std::string(str_, length_);
		return true;
	}
};

template<class JsonStream>
class JsonReader
{
  public:
	bool error = false;
	rj::Reader reader;
	JsonStream& stream;

	enum
	{
		IsReader = 1
	};

	explicit JsonReader(JsonStream& stream_)
	: stream(stream_)
	{
		// this wont exist with rapidjson from package managers
		// this requires the newest version of rapidjson from github.
		// it does not help that rapidjson has not icremented their version number,
		// so 1.1.0 could be the package version, but 1.1.0 is also the github version...
		reader.IterativeParseInit();
	}

	bool finish() const
	{
		// TODO (dootsie): do i need to make reader get an error for IterativeParseComplete to
		// signal?
		return !error && reader.IterativeParseComplete();
	}

	// null is kinda pointless, maybe placeholder data?
	void Null()
	{
		if(error) return; // preserve error offset.
		internal_null_json_reader handler;
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}

	void Bool(bool& b)
	{
		Bool_CB(internal_simple_setter{b}, {});
	}
	template<class Callback>
	void Bool_CB(Callback cb, bool)
	{
		if(error) return; // preserve error offset.
		MyBoolHandler handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Int(int& i)
	{
		Int_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	void Int_CB(Callback cb, int)
	{
		if(error) return; // preserve error offset.
		internal_int_json_reader handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Uint(unsigned& u)
	{
		Uint_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint_CB(Callback cb, unsigned)
	{
		if(error) return; // preserve error offset.
		internal_uint_json_reader handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Int64(int64_t& i)
	{
		Int64_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	void Int64_CB(Callback cb, int64_t)
	{
		if(error) return; // preserve error offset.
		internal_int64_json_reader handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Uint64(uint64_t& u)
	{
		Uint64_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint64_CB(Callback cb, uint64_t)
	{
		if(error) return; // preserve error offset.
		internal_uint64_json_reader handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t& u)
	{
		Uint16_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint16_CB(Callback cb, uint16_t)
	{
		if(error) return; // preserve error offset.
		// promote to uint
		internal_uint_promote_json_reader<uint16_t, Callback> handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Uint8(uint8_t& u)
	{
		Uint8_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint8_CB(Callback cb, uint8_t)
	{
		if(error) return; // preserve error offset.
		// promote to uint
		internal_uint_promote_json_reader<uint8_t, Callback> handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Double(double& d)
	{
		Double_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	void Double_CB(Callback cb, double)
	{
		if(error) return; // preserve error offset.
		internal_double_json_reader handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// float will promote to double, there shouldn't be a problem.
	void Float(float& d)
	{
		Float_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	void Float_CB(Callback cb, float)
	{
		if(error) return; // preserve error offset.
		// promote to double
		// a double to float can lose a significant ammount of resolution.
		// the rapidjson DOM has a IsLosslessFloat function that I can reference.
		internal_double_json_reader handler(cb);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// TODO (dootsie): validate utf8?
	void String(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	void String_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		if(error) return; // preserve error offset.
		internal_string_json_reader handler{cb, max_size};
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		Data_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		if(error) return; // preserve error offset.
		internal_data_json_reader handler(cb, max_size);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&str)[i])
	{
		if(error) return; // preserve error offset.
		internal_key_json_reader<i> handler(str);
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}

	void StartObject()
	{
		if(error) return; // preserve error offset.
		internal_startobject_json_reader handler;
		if(reader.IterativeParseComplete() ||
		   !reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void EndObject()
	{
		if(error) return; // preserve error offset.
		internal_endobject_json_reader handler;
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void StartArray()
	{
		if(error) return; // preserve error offset.
		internal_startarray_json_reader handler;
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void EndArray()
	{
		if(error) return; // preserve error offset.
		internal_endarray_json_reader handler;
		if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler) &&
		   !reader.IterativeParseComplete())
		{
			error = true;
		}
	}
};

// you could set JsonOutput to rj::StringBuffer, and JsonFormat to rj::PrettyWriter
template<class JsonOutput, class JsonFormat = rj::Writer<JsonOutput>>
class JsonWriter
{
  public:
	JsonFormat writer;

	enum
	{
		IsReader = 0
	};

	explicit JsonWriter(JsonOutput& output)
	: writer(output)
	{
	}

	bool finish() const
	{
		return writer.IsComplete();
	}

	// null is kinda pointless, maybe placeholder data?
	void Null()
	{
		writer.Null();
	}

	void Bool(bool b)
	{
		writer.Bool(b);
	}
	template<class Callback>
	void Bool_CB(Callback, bool b)
	{
		Bool(b);
	}
	void Int(int i)
	{
		writer.Int(i);
	}
	template<class Callback>
	void Int_CB(Callback, int i)
	{
		Int(i);
	}
	void Uint(unsigned u)
	{
		writer.Uint(u);
	}
	template<class Callback>
	void Uint_CB(Callback, unsigned u)
	{
		Uint(u);
	}
	void Int64(int64_t i)
	{
		writer.Int64(i);
	}
	template<class Callback>
	void Int64_CB(Callback, int64_t i)
	{
		Int64(i);
	}
	void Uint64(uint64_t u)
	{
		writer.Uint64(u);
	}
	template<class Callback>
	void Uint64_CB(Callback, uint64_t u)
	{
		Uint64(u);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t u)
	{
		writer.Uint(u);
	}
	template<class Callback>
	void Uint16_CB(Callback, uint16_t u)
	{
		Uint16(u);
	}
	void Uint8(uint8_t u)
	{
		writer.Uint(u);
	}
	template<class Callback>
	void Uint8_CB(Callback, uint8_t u)
	{
		Uint8(u);
	}
	void Double(double d)
	{
		writer.Double(d);
	}
	template<class Callback>
	void Double_CB(Callback, double d)
	{
		Double(d);
	}
	// float will promote to double.
	void Float(float d)
	{
		writer.Double(d);
	}
	template<class Callback>
	void Float_CB(Callback, float d)
	{
		Float(d);
	}
	void String(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		ASSERT(str.size() <= max_size);
		if(str.size() <= max_size)
		{
			writer.String(str.data(), str.size());
		}
		else
		{
			// not much information, but we are writing this
			// so you should pull out a debugger and check it yourself.
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			Null();
		}
	}
	template<class Callback>
	void String_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		ASSERT(str.size() <= max_size);
		if(str.size() <= max_size)
		{
			std::string tmp = base64_encode(str.data(), str.size());
			writer.String(str);
		}
		else
		{
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			Null();
		}
	}
	template<class Callback>
	void Data_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		Data(str, max_size);
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&str)[i])
	{
		writer.Key(str);
	}

	void StartObject()
	{
		writer.StartObject();
	}
	void EndObject()
	{
		writer.EndObject();
	}
	void StartArray()
	{
		writer.StartArray();
	}
	void EndArray()
	{
		writer.EndArray();
	}
};

// NOLINTEND

// with binary, you must error check the stream for errors because
// when EOF is reached good() and finish() will not be affected (due to rapidjson),
// you can use rj::FileReadStream and check the FILE* with ferror() + errno,
// but beware rj::StringStream. An alternative is KsonMemoryStream or custom stream.
// finish() and good() are affected by custom callback errors (but the offset will move).
// String() does not check valid utf8 encoding, there is no difference with Data().
template<class StreamReader>
class BinaryReader
{
  public:
	StreamReader& reader;
	bool success = true;

	enum
	{
		IsReader = 1
	};

	explicit BinaryReader(StreamReader& reader_)
	: reader(reader_)
	{
	}

	bool finish() const
	{
		return success;
	}

	// null is kinda pointless, maybe placeholder data?
	void Null() {}

	void Bool(bool& b)
	{
		b = reader.Take();
	}
	template<class Callback>
	void Bool_CB(Callback cb, bool)
	{
		success = success && cb(reader.Take());
	}
	void Int(int& i)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint32_t>(reader.Take());
		i = static_cast<int32_t>(tmp);
	}
	template<class Callback>
	void Int_CB(Callback cb, int)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint32_t>(reader.Take());
		success = success && cb(static_cast<int32_t>(tmp));
	}
	void Uint(unsigned& u)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint32_t>(reader.Take());
		u = tmp;
	}
	template<class Callback>
	void Uint_CB(Callback cb, unsigned)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint32_t>(reader.Take());
		success = success && cb(tmp);
	}
	void Int64(int64_t& i)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		i = static_cast<int64_t>(tmp);
	}
	template<class Callback>
	void Int64_CB(Callback cb, int64_t)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		success = success && cb(static_cast<int64_t>(tmp));
	}
	void Uint64(uint64_t& u)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		u = tmp;
	}
	template<class Callback>
	void Uint64_CB(Callback cb, uint64_t)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		success = success && cb(tmp);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t& u)
	{
		uint16_t tmp = static_cast<uint16_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		u = tmp;
	}
	template<class Callback>
	void Uint16_CB(Callback cb, uint16_t)
	{
		uint16_t tmp = static_cast<uint16_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		success = success && cb(tmp);
	}
	void Uint8(uint8_t& u)
	{
		u = static_cast<uint8_t>(reader.Take());
	}
	template<class Callback>
	void Uint8_CB(Callback cb, uint8_t)
	{
		success = success && cb(static_cast<uint8_t>(reader.Take()));
	}
	void Double(double& d)
	{
		uint64_t tmp;
		Uint64(tmp);
		// for portablility it is possible to use
		// frexp and ldexp which turns the float into 2 numbers (mantissa and exponent)
		// but I am just gonna pretend like x86 and ARM are 100% compatible,
		// and this is probably faster and more accurate, and supports NAN
		// But precicion and nan is not completely portable (I think).
		d = *reinterpret_cast<double*>(&tmp);
	}
	template<class Callback>
	void Double_CB(Callback cb, double)
	{
		uint64_t tmp;
		Uint64(tmp);
		success = success && cb(*reinterpret_cast<double*>(&tmp));
	}
	void Float(float& d)
	{
		uint32_t tmp;
		Uint(tmp);
		d = *reinterpret_cast<float*>(&tmp);
	}
	template<class Callback>
	void Float_CB(Callback cb, float)
	{
		uint32_t tmp;
		Uint(tmp);
		success = success && cb(*reinterpret_cast<float*>(&tmp));
	}
	void String(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		uint16_t size;
		if(success)
		{
			Uint16(size);
			if(size <= max_size)
			{
				str.clear();
				str.reserve(size);
				for(size_t i = 0; i < size; ++i)
				{
					str += reader.Take();
				}
			}
			else
			{
				success = false;
				serrf("string too large, max: %zu result: %" PRIu16 "\n", max_size, size);
			}
		}
	}
	template<class Callback>
	void String_CB(
		Callback cb, std::string_view, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		// this is a huge buffer, but windows should have a 1 mb large stack so 65kb isn't much.
		// I'm not very happy with this, I need a fread function but too lazy to benchmark.
		char buf[std::numeric_limits<uint16_t>::max()];
		uint16_t size;

		if(success)
		{
			Uint16(size);
			if(size <= max_size)
			{
				for(size_t i = 0; i < size; ++i)
				{
					buf[i] = reader.Take();
				}
				success = success && cb(buf, size);
			}
			else
			{
				success = false;
				serrf("string too large, max: %zu result: %" PRIu16 "\n", max_size, size);
			}
		}
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String_CB(cb, {}, max_size);
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&)[i])
	{
	}
	void StartObject() {}
	void EndObject() {}
	void StartArray() {}
	void EndArray() {}
};

template<class WriteStream>
class BinaryWriter
{
  public:
	WriteStream& output;

	enum
	{
		IsReader = 0
	};

	explicit BinaryWriter(WriteStream& output_)
	: output(output_)
	{
	}
	bool finish() const
	{
		return true;
	}

	// null is kinda pointless, maybe placeholder data?
	void Null() {}

	void Bool(bool b)
	{
		output.Put(b);
	}
	template<class Callback>
	void Bool_CB(Callback, bool b)
	{
		Bool(b);
	}
	void Int(int i)
	{
		output.Put(static_cast<char>(i >> 24));
		output.Put(static_cast<char>(i >> 16));
		output.Put(static_cast<char>(i >> 8));
		output.Put(static_cast<char>(i));
	}
	template<class Callback>
	void Int_CB(Callback, int i)
	{
		Int(i);
	}
	void Uint(unsigned u)
	{
		output.Put(static_cast<char>(u >> 24));
		output.Put(static_cast<char>(u >> 16));
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint_CB(Callback, unsigned u)
	{
		Uint(u);
	}
	void Int64(int64_t i)
	{
		output.Put(static_cast<char>(i >> 56));
		output.Put(static_cast<char>(i >> 48));
		output.Put(static_cast<char>(i >> 40));
		output.Put(static_cast<char>(i >> 32));
		output.Put(static_cast<char>(i >> 24));
		output.Put(static_cast<char>(i >> 16));
		output.Put(static_cast<char>(i >> 8));
		output.Put(static_cast<char>(i));
	}
	template<class Callback>
	void Int64_CB(Callback, int64_t i)
	{
		Int64(i);
	}
	void Uint64(uint64_t u)
	{
		output.Put(static_cast<char>(u >> 56));
		output.Put(static_cast<char>(u >> 48));
		output.Put(static_cast<char>(u >> 40));
		output.Put(static_cast<char>(u >> 32));
		output.Put(static_cast<char>(u >> 24));
		output.Put(static_cast<char>(u >> 16));
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint64_CB(Callback, uint64_t u)
	{
		Uint64(u);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t u)
	{
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint16_CB(Callback, uint16_t u)
	{
		Uint16(u);
	}
	void Uint8(uint8_t u)
	{
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint8_CB(Callback, uint8_t u)
	{
		Uint8(u);
	}
	void Double(double d)
	{
		uint64_t fhold = *reinterpret_cast<uint64_t*>(&d);
		output.Put(static_cast<char>(fhold >> 56));
		output.Put(static_cast<char>(fhold >> 48));
		output.Put(static_cast<char>(fhold >> 40));
		output.Put(static_cast<char>(fhold >> 32));
		output.Put(static_cast<char>(fhold >> 24));
		output.Put(static_cast<char>(fhold >> 16));
		output.Put(static_cast<char>(fhold >> 8));
		output.Put(static_cast<char>(fhold));
	}
	template<class Callback>
	void Double_CB(Callback, double d)
	{
		Double(d);
	}
	// float will promote to double.
	void Float(float d)
	{
		uint32_t fhold = *reinterpret_cast<uint32_t*>(&d);
		output.Put(static_cast<char>(fhold >> 24));
		output.Put(static_cast<char>(fhold >> 16));
		output.Put(static_cast<char>(fhold >> 8));
		output.Put(static_cast<char>(fhold));
	}
	template<class Callback>
	void Float_CB(Callback, float d)
	{
		Float(d);
	}
	void String(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		ASSERT(str.size() <= max_size);
		if(str.size() <= max_size)
		{
			Uint16(str.size());
			size_t size = str.size();
			for(size_t i = 0; i < size; ++i)
			{
				output.Put(str[i]);
			}
		}
		else
		{
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
		}
	}
	template<class Callback>
	void String_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&)[i])
	{
	}

	void StartObject() {}
	void EndObject() {}
	void StartArray() {}
	void EndArray() {}
};

// This is like rj::MemoryStream but Tell() will go beyond the size (for error checking).
// the problem with rj::StringStream is that it won't work with BinaryReader,
// because rj::StringStream doesn't check for overrun because NULL is used for EOF,
// but BinaryReader cant check for a NULL terminater because the data is binary.
// So for BinaryReader, you have to use this or else Bad Things Will Happen (TM)
struct KsonMemoryStream
{
	typedef char Ch;

	const char* src; //!< Current read position.
	const char* head; //!< Original head of the string.
	const char* end;

	explicit KsonMemoryStream(const char* src_, const char* end_)
	: src(src_)
	, head(src_)
	, end(end_)
	{
	}

	char Peek() const
	{
		return (src >= end ? '\0' : *src);
	}
	char Take()
	{
		// the comma operator is very important
		return (src >= end ? (src++, '\0') : *src++);
	}
	size_t Tell() const
	{
		return static_cast<size_t>(src - head);
	}

	char* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	void Put(char)
	{
		ASSERT(false);
	}
	void Flush()
	{
		ASSERT(false);
	}
	size_t PutEnd(char*)
	{
		ASSERT(false);
		return 0;
	}
};

// This is 99% copy pasted from rapidjson::FileReadStream, but modified for use by RWops,
// and this will also open the ability to check for EOF error,
// and the callback can optionally check for errors too.
// the callback signature is <size_t(char* buffer, size_t read_num)> returns bytes read.
template<class Callback>
class KsonCB_ReadStream
{
  public:
	typedef char Ch; //!< Character type (byte).

	
	KsonCB_ReadStream(Callback cb_, char* buffer, size_t bufferSize)
	: cb(cb_)
	, buffer_(buffer)
	, bufferSize_(bufferSize)
	, bufferLast_(0)
	, current_(buffer_)
	, readCount_(0)
	, count_(0)
	, eof_(false)
	{
		Read();
	}

	Ch Peek() const
	{
		return *current_;
	}
	Ch Take()
	{
		Ch c = *current_;
		Read();
		return c;
	}
	size_t Tell() const
	{
		return count_ + (current_ - buffer_);
	}

	// Not implemented
	void Put(Ch)
	{
		ASSERT(false);
	}
	void Flush()
	{
		ASSERT(false);
	}
	Ch* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	size_t PutEnd(Ch*)
	{
		ASSERT(false);
		return 0;
	}

  private:
	void Read()
	{
		if(current_ < bufferLast_)
		{
			++current_;
		}
		else if(!eof_)
		{
			count_ += readCount_;
			readCount_ = cb(buffer_, bufferSize_);
			bufferLast_ = buffer_ + readCount_ - 1;
			current_ = buffer_;

			if(readCount_ < bufferSize_)
			{
				buffer_[readCount_] = '\0';
				++bufferLast_;
				eof_ = true;
			}
		}
	}

	Callback cb;
	Ch* buffer_;
	size_t bufferSize_;
	Ch* bufferLast_;
	Ch* current_;
	size_t readCount_;
	size_t count_; //!< Number of characters read
	bool eof_;
};

// this is copy pasted from rapidjson::FileWriteStream
template<class Callback>
class KsonCB_WriteStream
{
  public:
	typedef char Ch; //!< Character type. Only support char.

	KsonCB_WriteStream(Callback cb_, char* buffer, size_t bufferSize)
	: cb(cb_)
	, buffer_(buffer)
	, bufferEnd_(buffer + bufferSize)
	, current_(buffer_)
	{
	}

	void Put(char c)
	{
		if(current_ >= bufferEnd_) Flush();

		*current_++ = c;
	}

	void Flush()
	{
		if(current_ != buffer_)
		{
			size_t result = cb(buffer_, static_cast<size_t>(current_ - buffer_));
			if(result < static_cast<size_t>(current_ - buffer_))
			{
				// failure deliberately ignored at this time
				// added to avoid warn_unused_result build errors
			}
			current_ = buffer_;
		}
	}

	// Not implemented
	char Peek() const
	{
		ASSERT(false);
		return 0;
	}
	char Take()
	{
		ASSERT(false);
		return 0;
	}
	size_t Tell() const
	{
		ASSERT(false);
		return 0;
	}
	char* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	size_t PutEnd(char*)
	{
		ASSERT(false);
		return 0;
	}

  private:
	Callback cb;
	char* buffer_;
	char* bufferEnd_;
	char* current_;
};