#pragma once

// This is a JSON API for a restrictive style of JSON that supports binary serialization.
// I want to call this KSON to distinguish itself as NOT json, but it's just JSON+Binary.
// The most important feature is the symetric read / write system using templates.
// Used when the file is exclusively generated by the program, not a human.
// This was inspired by a example called "archiver" in the rapidjson examples.
// Limitations:
// Variables must be ordered, no variable can be missing, no variable can be skipped over.
// Keys, objects, arrays, are stubbed away in the binary serializer.
// An annoying limitation is that dynamic sized arrays requires you to specifiy
// The size of an array ahead of the data you load (like a pascal string).
// Arrays require you to also check the IsWriter flag to properly work with dynamic arrays.
// Note:
// Performance is not a goal for the Binary format, because rapidjson is surprisingly fast,
// (note that rapidjson DOM is on equal performance as the binary format for my simple tests)
// But the benefit is the lack of care needed with the length of key strings in JSON,
// So you can have descriptive names of every variable without a care,
// and even group up variables in redundant object scopes.
// To insert comments you can use "key":null, useful for type ID's.

// TODO:
//-the base64 serializer needs tidying
//-even though it's completely redundant, maybe I should have a NDEBUG optimized out
// stack that checks that all Key Start Stop Array Object are matched correctly in BinaryWriter
// but Just testing Json should detect any malformed Json
// (-DNDEBUG will remove rapidjson checks for the writer but it will quickly segfault)
//-If you write a string/data that is longer than the max size, you will assert.
// maybe it would be nice if I used std::source_location and print that into serrf,
// but a backtrace from a debugger has much more information (include a trace in the message?),
// but this error SHOULD only be a programmer error (why was the string that long?)
//-The example is overcomplicated, maybe write a convenience wrapper that "just works"?
//-clean up error messages (maybe make every message include what class and function was called?)
//-I am noticing that binary bloat can be somewhat of a problem, but hopefully it doesn't scale.

// example
#if 0
//shared simple serialization:
//creates: {"i":N, "d":N}
template<class Archive>
void serialize_data_type(Archive& ar, data_type& data)
{
	ar.StartObject();
	ar.Key("i");
	ar.Int(data.i);
	ar.Key("d");
	ar.Double(data.d);
	ar.EndObject();
}

//shared dynamic arrays:
//creates {"size":N, "array":[...]}
template<class Archive>
bool serialize_data_group(Archive& ar, std::vector<data_type>& group_data)
{
	ar.StartObject();
	ar.Key("size");
	uint16_t size = std::size(group_data);
	
	ar.Uint16(size);

	//this could be put into Uint16_CB as well,
	//but that only checks for the reader.
	if(size > 2)
	{
		serr("error\n");
		return false;
	}

	if(Archive::IsReader)
	{
		//the reader needs to make space for the
		//pieces to be read.
		data.resize(size);
	}

	ar.Key("array");
	ar.StartArray();
	for(data_type& entry : group_data)
	{
		serialize_data_type(ar, entry);
	}
	ar.EndArray();
	ar.EndObject();
}

//writer setup:
{
	//fill the input with data
	std::vector<data_type> input = {{1,1.1}, {2,2.2}};

	//this stores the result.
	rj::StringBuffer sb;

	//replace "json_memory" with "binary" instead of "json"
	//or "stream" (RWops*) instead of "memory".
	if(!kson_write_json_memory(
			[&](auto& ar) -> bool {
				return serialize_data_group(ar, input);
			},
			sb,
			"store_data_group"))
	{
		//error!
	}
	std::string contents(sb.GetString(), sb.GetLength());
}

//reader setup:
{
	std::vector<data_type> output;

	if(!kson_read_json_memory(
			[&output](auto& ar) -> bool {
				return serialize_data_group(ar, output);
			},
			contents.c_str(),
			contents.size(),
			"load_data_group"))
	{
		//error!
	}

	//use output
}

#endif

#include <cmath>
#define RAPIDJSON_ASSERT ASSERT
#define RAPIDJSON_HAS_STDSTRING 1

#include <rapidjson/reader.h>

// needed for the convenience functions
#include <rapidjson/error/en.h>
#include <rapidjson/prettywriter.h>
#include "RWops.h"

namespace rj = rapidjson;

// I got this from stack overflow https://stackoverflow.com/a/41094722
static const int B64index[256] = {
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
	0,	62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,	0,	0,	0,	0,
	0,	0,	0,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10, 11, 12, 13, 14, 15, 16, 17, 18,
	19, 20, 21, 22, 23, 24, 25, 0,	0,	0,	0,	63, 0,	26, 27, 28, 29, 30, 31, 32, 33,
	34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};

// NOLINTBEGIN

inline std::string b64decode(const void* data, const size_t len)
{
	unsigned char* p = (unsigned char*)data;
	int pad = len > 0 && (len % 4 || p[len - 1] == '=');
	const size_t L = ((len + 3) / 4 - pad) * 4;
	std::string str(L / 4 * 3 + pad, '\0');

	unsigned char* out = (unsigned char*)&str[0];

	for(size_t i = 0, j = 0; i < L; i += 4)
	{
		int n = B64index[p[i]] << 18 | B64index[p[i + 1]] << 12 | B64index[p[i + 2]] << 6 |
				B64index[p[i + 3]];
		out[j++] = n >> 16;
		out[j++] = n >> 8 & 0xFF;
		out[j++] = n & 0xFF;
	}
	if(pad)
	{
		int n = B64index[p[L]] << 18 | B64index[p[L + 1]] << 12;
		out[str.size() - 1] = n >> 16;

		if(len > L + 2 && p[L + 2] != '=')
		{
			n |= B64index[p[L + 2]] << 6;
			str.push_back(static_cast<char>(n >> 8 & 0xFF));
			out = (unsigned char*)&str[0];
		}
	}
	return str;
}

/*
 * Base64 encoding/decoding (RFC1341)
 * Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi>
 *
 * This software may be distributed under the terms of the BSD license.
 * See README for more details.
 */

// 2016-12-12 - Gaspard Petit : Slightly modified to return a std::string
// instead of a buffer allocated with malloc.

static const unsigned char base64_table[65] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
/**
 * base64_encode - Base64 encode
 * @src: Data to be encoded
 * @len: Length of the data to be encoded
 * @out_len: Pointer to output length variable, or %NULL if not used
 * Returns: Allocated buffer of out_len bytes of encoded data,
 * or empty string on failure
 */
inline std::string base64_encode(const void* src, size_t len)
{
	unsigned char *out, *pos;
	const unsigned char *end, *in;

	size_t olen;

	olen = 4 * ((len + 2) / 3); /* 3-byte blocks to 4-byte */

	if(olen < len) return std::string(); /* integer overflow */

	std::string outStr;
	outStr.resize(olen);
	out = (unsigned char*)&outStr[0];

	end = (unsigned char*)src + len;
	in = (unsigned char*)src;
	pos = out;
	while(end - in >= 3)
	{
		*pos++ = base64_table[in[0] >> 2];
		*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		*pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
		*pos++ = base64_table[in[2] & 0x3f];
		in += 3;
	}

	if(end - in)
	{
		*pos++ = base64_table[in[0] >> 2];
		if(end - in == 1)
		{
			*pos++ = base64_table[(in[0] & 0x03) << 4];
			*pos++ = '=';
		}
		else
		{
			*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
			*pos++ = base64_table[(in[1] & 0x0f) << 2];
		}
		*pos++ = '=';
	}

	return outStr;
}

// NOLINTEND

template<class Callback>
class internal_bool_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_bool_json_handler<Callback>>
{
  public:
	Callback call;

	explicit internal_bool_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		// TODO (dootsie): I could easily create my own rj::BaseReaderHandler
		// which will include the result that was not expected, because this is vague.
		serr("expected bool\n");
		return false;
	}
	bool Bool(bool b)
	{
		return call(b);
	}
};

template<class Callback>
class internal_int_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_int_json_handler<Callback>>
{
  public:
	Callback call;

	explicit internal_int_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected int\n");
		return false;
	}
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		if(u <= std::numeric_limits<int>::max())
		{
			return call(u);
		}
		serrf("number too large, max: %d, result: %u\n", std::numeric_limits<int>::max(), u);
		return false;
	}
};

template<class Callback>
class internal_uint_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint_json_handler<Callback>>
{
  public:
	Callback call;

	explicit internal_uint_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected uint\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
};

template<class Callback>
class internal_int64_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_int64_json_handler<Callback>>
{
  public:
	Callback call;

	explicit internal_int64_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected int64\n");
		return false;
	}
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
	bool Int64(int64_t i)
	{
		return call(i);
	}
	bool Uint64(uint64_t u)
	{
		if(u <= std::numeric_limits<int64_t>::max())
		{
			return call(u);
		}
		serrf(
			"number too large, max: %" PRIi64 ", result: %" PRIu64 "\n",
			std::numeric_limits<int64_t>::max(),
			u);
		return false;
	}
};

template<class Callback>
class internal_uint64_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint64_json_handler<Callback>>
{
  public:
	Callback call;

	explicit internal_uint64_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected uint64\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
	bool Uint64(uint64_t u)
	{
		return call(u);
	}
};

template<class Callback>
class internal_double_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_double_json_handler<Callback>>
{
  public:
	Callback call;

	explicit internal_double_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected double\n");
		return false;
	}
// I am tempted to disable this, just for strictness.
#if 1
	bool Int(int i)
	{
		return call(i);
	}
	bool Uint(unsigned u)
	{
		return call(u);
	}
#endif
	bool Double(double d)
	{
		return call(d);
	}
};

template<class T, class Callback>
class internal_uint_promote_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_uint_promote_json_handler<T, Callback>>
{
  public:
	Callback call;

	explicit internal_uint_promote_json_handler(Callback cb)
	: call(cb)
	{
	}
	bool Default()
	{
		serr("expected unsigned number\n");
		return false;
	}
	bool Uint(unsigned u)
	{
		if(u <= std::numeric_limits<T>::max())
		{
			return call(u);
		}
		serrf(
			"number too large, max: %zu, result: %u\n",
			static_cast<size_t>(std::numeric_limits<T>::max()),
			u);
		return false;
	}
};

template<class Callback>
class internal_string_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_string_json_handler<Callback>>
{
  public:
	Callback call;
	size_t max_size;

	explicit internal_string_json_handler(Callback cb, size_t max_size_)
	: call(cb)
	, max_size(max_size_)
	{
	}
	bool Default()
	{
		serr("expected string\n");
		return false;
	}
	bool String(const char* str, rj::SizeType length, bool)
	{
		if(length <= max_size)
		{
			return call(str, length);
		}
		serrf("string too large, max: %zu result: %zu\n", max_size, static_cast<size_t>(length));
		return false;
	}
};

template<class Callback>
class internal_data_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_data_json_handler<Callback>>
{
  public:
	Callback call;
	size_t max_size;

	explicit internal_data_json_handler(Callback cb, size_t max_size_)
	: call(cb)
	, max_size(max_size_)
	{
	}
	bool Default()
	{
		serr("expected data\n");
		return false;
	}
	bool String(const char* str, rj::SizeType length, bool)
	{
		std::string tmp = b64decode(str, length);
		if(tmp.size() <= max_size)
		{
			return call(tmp.data(), tmp.size());
		}
		serrf("string too large, max: %zu result: %zu\n", max_size, tmp.size());
		return false;
	}
};

template<size_t size>
class internal_key_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_key_json_handler<size>>
{
  public:
	const char (&s)[size];

	explicit internal_key_json_handler(const char (&s_)[size])
	: s(s_)
	{
	}
	bool Default()
	{
		serrf("expected key type: \"%s\"\n", s);
		return false;
	}
	bool Key(const char* str, rj::SizeType length, bool)
	{
		if(length == size - 1 && strncmp(str, s, size - 1) == 0)
		{
			return true;
		}
		serrf("mismatching keys expected: \"%s\", result: \"%s\"\n", str, s);
		return false;
	}
};

class internal_startobject_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_startobject_json_handler>
{
  public:
	bool Default()
	{
		serr("expected '{'\n");
		return false;
	}
	bool StartObject()
	{
		return true;
	}
};

class internal_endobject_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_endobject_json_handler>
{
  public:
	bool Default()
	{
		serr("expected '}'\n");
		return false;
	}
	bool EndObject(rj::SizeType)
	{
		return true;
	}
};

class internal_startarray_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_startarray_json_handler>
{
  public:
	bool Default()
	{
		serr("expected '['\n");
		return false;
	}
	bool StartArray()
	{
		return true;
	}
};

class internal_endarray_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_endarray_json_handler>
{
  public:
	bool Default()
	{
		serr("expected ']'\n");
		return false;
	}
	bool EndArray(rj::SizeType)
	{
		return true;
	}
};

class internal_null_json_handler
: public rj::BaseReaderHandler<rj::UTF8<>, internal_null_json_handler>
{
  public:
	bool Default()
	{
		serr("expected null\n");
		return false;
	}
	bool Null()
	{
		return true;
	}
};

template<class T>
struct internal_simple_setter
{
	T& b;
	explicit internal_simple_setter(T& b_)
	: b(b_)
	{
	}
	bool operator()(T b_)
	{
		b = b_;
		return true;
	}
};

struct internal_string_setter
{
	std::string& str;
	bool operator()(const char* str_, rj::SizeType length_)
	{
		str = std::string(str_, length_);
		return true;
	}
};

template<class JsonStream>
class JsonReader
{
  public:
	bool error = false;
	rj::Reader reader;
	JsonStream& stream;

	enum
	{
		IsReader = 1
	};

	explicit JsonReader(JsonStream& stream_)
	: stream(stream_)
	{
		// this wont exist with rapidjson from package managers
		// this requires the newest version of rapidjson from github.
		// it does not help that rapidjson has not icremented their version number,
		// so 1.1.0 could be the package version, but 1.1.0 is also the github version...
		reader.IterativeParseInit();
	}

	bool good() const
	{
		return !error;
	}

	bool is_complete() const
	{
		return reader.IterativeParseComplete();
	}

	void Null()
	{
		if(error) return; // preserve error offset.
		internal_null_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}

	void Bool(bool& b)
	{
		Bool_CB(internal_simple_setter{b}, {});
	}
	template<class Callback>
	void Bool_CB(Callback cb, bool)
	{
		if(error) return; // preserve error offset.
		internal_bool_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Int(int& i)
	{
		Int_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	void Int_CB(Callback cb, int)
	{
		if(error) return; // preserve error offset.
		internal_int_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Uint(unsigned& u)
	{
		Uint_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint_CB(Callback cb, unsigned)
	{
		if(error) return; // preserve error offset.
		internal_uint_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Int64(int64_t& i)
	{
		Int64_CB(internal_simple_setter{i}, {});
	}
	template<class Callback>
	void Int64_CB(Callback cb, int64_t)
	{
		if(error) return; // preserve error offset.
		internal_int64_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Uint64(uint64_t& u)
	{
		Uint64_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint64_CB(Callback cb, uint64_t)
	{
		if(error) return; // preserve error offset.
		internal_uint64_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t& u)
	{
		Uint16_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint16_CB(Callback cb, uint16_t)
	{
		if(error) return; // preserve error offset.
		// promote to uint
		internal_uint_promote_json_handler<uint16_t, Callback> handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Uint8(uint8_t& u)
	{
		Uint8_CB(internal_simple_setter{u}, {});
	}
	template<class Callback>
	void Uint8_CB(Callback cb, uint8_t)
	{
		if(error) return; // preserve error offset.
		// promote to uint
		internal_uint_promote_json_handler<uint8_t, Callback> handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void Double(double& d)
	{
		Double_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	void Double_CB(Callback cb, double)
	{
		if(error) return; // preserve error offset.
		internal_double_json_handler handler(cb);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// float will promote to double, there shouldn't be a problem.
	void Float(float& d)
	{
		Double_CB(internal_simple_setter{d}, {});
	}
	template<class Callback>
	void Float_CB(Callback cb, float)
	{
		// promote to double
		Double_CB(cb, {});
	}
	void String(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	void String_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		if(error) return; // preserve error offset.
		internal_string_json_handler handler{cb, max_size};
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		Data_CB(internal_string_setter{str}, {}, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		if(error) return; // preserve error offset.
		internal_data_json_handler handler(cb, max_size);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&str)[i])
	{
		if(error) return; // preserve error offset.
		internal_key_json_handler<i> handler(str);
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}

	void StartObject()
	{
		if(error) return; // preserve error offset.
		internal_startobject_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void EndObject()
	{
		if(error) return; // preserve error offset.
		internal_endobject_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void StartArray()
	{
		if(error) return; // preserve error offset.
		internal_startarray_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
	void EndArray()
	{
		if(error) return; // preserve error offset.
		internal_endarray_json_handler handler;
		if(reader.IterativeParseComplete())
		{
			serrf("write after complete: %s\n", __func__);
			error = true;
		}
		else if(!reader.IterativeParseNext<rj::kParseCommentsFlag>(stream, handler))
		{
			error = true;
		}
	}
};

// you could set JsonOutput to rj::StringBuffer
template<class JsonOutput, class JsonFormat = rj::PrettyWriter<JsonOutput>>
class JsonWriter
{
  public:
	JsonFormat writer;

	enum
	{
		IsReader = 0
	};

	explicit JsonWriter(JsonOutput& output)
	: writer(output)
	{
	}

	bool is_complete() const
	{
		return writer.IsComplete();
	}

	void Null()
	{
		writer.Null();
	}

	void Bool(bool b)
	{
		writer.Bool(b);
	}
	template<class Callback>
	void Bool_CB(Callback, bool b)
	{
		Bool(b);
	}
	void Int(int i)
	{
		writer.Int(i);
	}
	template<class Callback>
	void Int_CB(Callback, int i)
	{
		Int(i);
	}
	void Uint(unsigned u)
	{
		writer.Uint(u);
	}
	template<class Callback>
	void Uint_CB(Callback, unsigned u)
	{
		Uint(u);
	}
	void Int64(int64_t i)
	{
		writer.Int64(i);
	}
	template<class Callback>
	void Int64_CB(Callback, int64_t i)
	{
		Int64(i);
	}
	void Uint64(uint64_t u)
	{
		writer.Uint64(u);
	}
	template<class Callback>
	void Uint64_CB(Callback, uint64_t u)
	{
		Uint64(u);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t u)
	{
		writer.Uint(u);
	}
	template<class Callback>
	void Uint16_CB(Callback, uint16_t u)
	{
		Uint16(u);
	}
	void Uint8(uint8_t u)
	{
		writer.Uint(u);
	}
	template<class Callback>
	void Uint8_CB(Callback, uint8_t u)
	{
		Uint8(u);
	}
	void Double(double d)
	{
		// it's possible that NaN or Inf can cause an error.
		if(!writer.Double(d))
		{
			// assert because the message gives no information.
			// and its the programmers responsibility to not create NANs.
			ASSERT(false && "failed to write double");
			serrf("failed to write double: %f\n", d);
		}
	}
	template<class Callback>
	void Double_CB(Callback, double d)
	{
		Double(d);
	}
	// float will promote to double.
	void Float(float d)
	{
		Double(d);
	}
	template<class Callback>
	void Float_CB(Callback, float d)
	{
		Double(d);
	}
	void String(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		ASSERT(str.size() <= max_size);
		if(str.size() <= max_size)
		{
			writer.String(str.data(), str.size());
		}
		else
		{
			// not much information, but we are writing this
			// so you should pull out a debugger and check it yourself.
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			Null();
		}
	}
	template<class Callback>
	void String_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		ASSERT(str.size() <= max_size);
		if(str.size() <= max_size)
		{
			std::string tmp = base64_encode(str.data(), str.size());
			writer.String(tmp.data(), tmp.size());
		}
		else
		{
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
			Null();
		}
	}
	template<class Callback>
	void Data_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		Data(str, max_size);
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&str)[i])
	{
		writer.Key(str);
	}

	void StartObject()
	{
		writer.StartObject();
	}
	void EndObject()
	{
		writer.EndObject();
	}
	void StartArray()
	{
		writer.StartArray();
	}
	void EndArray()
	{
		writer.EndArray();
	}
};

// NOLINTEND

// with binary, you must error check the stream for errors because
// when EOF is reached good() and finish() will not be affected (due to rapidjson),
// you can use rj::FileReadStream and check the FILE* with ferror() + errno,
// but beware rj::StringStream. An alternative is KsonMemoryStream or custom stream.
// finish() and good() are affected by custom callback errors (but the offset will move).
// String() does not check valid utf8 encoding, there is no difference with Data().
template<class StreamReader>
class BinaryReader
{
  public:
	StreamReader& reader;
	bool error = false;

	enum
	{
		IsReader = 1
	};

	explicit BinaryReader(StreamReader& reader_)
	: reader(reader_)
	{
	}

	bool good() const
	{
		return !error;
	}

	void Null() {}

	void Bool(bool& b)
	{
		b = reader.Take();
	}
	template<class Callback>
	void Bool_CB(Callback cb, bool)
	{
		error = error || !cb(reader.Take());
	}
	void Int(int& i)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		i = static_cast<int32_t>(tmp);
	}
	template<class Callback>
	void Int_CB(Callback cb, int)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		error = error || !cb(static_cast<int32_t>(tmp));
	}
	void Uint(unsigned& u)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		u = tmp;
	}
	template<class Callback>
	void Uint_CB(Callback cb, unsigned)
	{
		uint32_t tmp = static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint32_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		error = error || !cb(tmp);
	}
	void Int64(int64_t& i)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		i = static_cast<int64_t>(tmp);
	}
	template<class Callback>
	void Int64_CB(Callback cb, int64_t)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		error = error || !cb(static_cast<int64_t>(tmp));
	}
	void Uint64(uint64_t& u)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		u = tmp;
	}
	template<class Callback>
	void Uint64_CB(Callback cb, uint64_t)
	{
		uint64_t tmp = static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 56;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 48;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 40;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 32;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 24;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 16;
		tmp |= static_cast<uint64_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		error = error || !cb(tmp);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t& u)
	{
		uint16_t tmp = static_cast<uint16_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		u = tmp;
	}
	template<class Callback>
	void Uint16_CB(Callback cb, uint16_t)
	{
		uint16_t tmp = static_cast<uint16_t>(static_cast<uint8_t>(reader.Take())) << 8;
		tmp |= static_cast<uint8_t>(reader.Take());
		error = error || !cb(tmp);
	}
	void Uint8(uint8_t& u)
	{
		u = static_cast<uint8_t>(reader.Take());
	}
	template<class Callback>
	void Uint8_CB(Callback cb, uint8_t)
	{
		error = error || !cb(static_cast<uint8_t>(reader.Take()));
	}
	void Double(double& d)
	{
		uint64_t tmp;
		Uint64(tmp);
		// for portablility it is possible to use
		// frexp and ldexp which turns the float into 2 numbers (mantissa and exponent)
		// but I am just gonna pretend like x86 and ARM are 100% compatible,
		// and this is probably faster and more accurate, and supports NAN
		// But precicion and nan is not completely portable (I think).
		d = *reinterpret_cast<double*>(&tmp);

		// TODO (dootsie): write a handler that does this check for the callback
		ASSERT(std::isfinite(d) && "failed to read double");
		if(!std::isfinite(d))
		{
			serrf("failed to read double: %f\n", d);
		}
	}
	template<class Callback>
	void Double_CB(Callback cb, double)
	{
		uint64_t tmp;
		Uint64(tmp);
		error = error || !cb(*reinterpret_cast<double*>(&tmp));
	}
	void Float(float& d)
	{
		uint32_t tmp;
		Uint(tmp);
		d = *reinterpret_cast<float*>(&tmp);

		ASSERT(std::isfinite(d) && "failed to read float");
		if(!std::isfinite(d))
		{
			serrf("failed to read float: %f\n", d);
		}
	}
	template<class Callback>
	void Float_CB(Callback cb, float)
	{
		uint32_t tmp;
		Uint(tmp);
		error = error || !cb(*reinterpret_cast<float*>(&tmp));
	}
	void String(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		uint16_t size;
		if(!error)
		{
			Uint16(size);
			if(size <= max_size)
			{
				str.clear();
				str.reserve(size);
				for(size_t i = 0; i < size; ++i)
				{
					str += reader.Take();
				}
			}
			else
			{
				error = true;
				serrf("string too large, max: %zu result: %" PRIu16 "\n", max_size, size);
			}
		}
	}
	template<class Callback>
	void String_CB(
		Callback cb, std::string_view, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		// this is a huge buffer, but windows should have a 1 mb large stack so 65kb isn't much.
		// I'm not very happy with this, I need a fread function but too lazy to benchmark.
		char buf[std::numeric_limits<uint16_t>::max()];
		uint16_t size;

		if(!error)
		{
			Uint16(size);
			if(size <= max_size)
			{
				for(size_t i = 0; i < size; ++i)
				{
					buf[i] = reader.Take();
				}
				error = error || !cb(buf, size);
			}
			else
			{
				error = true;
				serrf("string too large, max: %zu result: %" PRIu16 "\n", max_size, size);
			}
		}
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string& str, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback cb, std::string_view, uint16_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String_CB(cb, {}, max_size);
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&)[i])
	{
	}
	void StartObject() {}
	void EndObject() {}
	void StartArray() {}
	void EndArray() {}
};

template<class WriteStream>
class BinaryWriter
{
  public:
	WriteStream& output;

	enum
	{
		IsReader = 0
	};

	explicit BinaryWriter(WriteStream& output_)
	: output(output_)
	{
	}

	void Null() {}

	void Bool(bool b)
	{
		output.Put(b);
	}
	template<class Callback>
	void Bool_CB(Callback, bool b)
	{
		Bool(b);
	}
	void Int(int i)
	{
		output.Put(static_cast<char>(i >> 24));
		output.Put(static_cast<char>(i >> 16));
		output.Put(static_cast<char>(i >> 8));
		output.Put(static_cast<char>(i));
	}
	template<class Callback>
	void Int_CB(Callback, int i)
	{
		Int(i);
	}
	void Uint(unsigned u)
	{
		output.Put(static_cast<char>(u >> 24));
		output.Put(static_cast<char>(u >> 16));
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint_CB(Callback, unsigned u)
	{
		Uint(u);
	}
	void Int64(int64_t i)
	{
		output.Put(static_cast<char>(i >> 56));
		output.Put(static_cast<char>(i >> 48));
		output.Put(static_cast<char>(i >> 40));
		output.Put(static_cast<char>(i >> 32));
		output.Put(static_cast<char>(i >> 24));
		output.Put(static_cast<char>(i >> 16));
		output.Put(static_cast<char>(i >> 8));
		output.Put(static_cast<char>(i));
	}
	template<class Callback>
	void Int64_CB(Callback, int64_t i)
	{
		Int64(i);
	}
	void Uint64(uint64_t u)
	{
		output.Put(static_cast<char>(u >> 56));
		output.Put(static_cast<char>(u >> 48));
		output.Put(static_cast<char>(u >> 40));
		output.Put(static_cast<char>(u >> 32));
		output.Put(static_cast<char>(u >> 24));
		output.Put(static_cast<char>(u >> 16));
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint64_CB(Callback, uint64_t u)
	{
		Uint64(u);
	}
	// shorts and bytes in json are promoted.
	// I don't use signed numbers, if you need them, then implement it.
	void Uint16(uint16_t u)
	{
		output.Put(static_cast<char>(u >> 8));
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint16_CB(Callback, uint16_t u)
	{
		Uint16(u);
	}
	void Uint8(uint8_t u)
	{
		output.Put(static_cast<char>(u));
	}
	template<class Callback>
	void Uint8_CB(Callback, uint8_t u)
	{
		Uint8(u);
	}
	void Double(double d)
	{
		ASSERT(std::isfinite(d) && "failed to write double");
		if(!std::isfinite(d))
		{
			serrf("failed to write double: %f\n", d);
		}

		uint64_t fhold = *reinterpret_cast<uint64_t*>(&d);
		output.Put(static_cast<char>(fhold >> 56));
		output.Put(static_cast<char>(fhold >> 48));
		output.Put(static_cast<char>(fhold >> 40));
		output.Put(static_cast<char>(fhold >> 32));
		output.Put(static_cast<char>(fhold >> 24));
		output.Put(static_cast<char>(fhold >> 16));
		output.Put(static_cast<char>(fhold >> 8));
		output.Put(static_cast<char>(fhold));
	}
	template<class Callback>
	void Double_CB(Callback, double d)
	{
		Double(d);
	}
	// float will promote to double.
	void Float(float d)
	{
		ASSERT(std::isfinite(d) && "failed to write float");
		if(!std::isfinite(d))
		{
			serrf("failed to write float: %f\n", d);
		}
		uint32_t fhold = *reinterpret_cast<uint32_t*>(&d);
		output.Put(static_cast<char>(fhold >> 24));
		output.Put(static_cast<char>(fhold >> 16));
		output.Put(static_cast<char>(fhold >> 8));
		output.Put(static_cast<char>(fhold));
	}
	template<class Callback>
	void Float_CB(Callback, float d)
	{
		Float(d);
	}
	void String(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		ASSERT(max_size <= std::numeric_limits<uint16_t>::max());
		ASSERT(str.size() <= max_size);
		if(str.size() <= max_size)
		{
			Uint16(str.size());
			size_t size = str.size();
			for(size_t i = 0; i < size; ++i)
			{
				output.Put(str[i]);
			}
		}
		else
		{
			serrf("string too large, max: %zu result: %zu\n", max_size, str.size());
		}
	}
	template<class Callback>
	void String_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	// json requires valid utf8, and binary wont work.
	void Data(std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}
	template<class Callback>
	void Data_CB(
		Callback, std::string_view str, size_t max_size = std::numeric_limits<uint16_t>::max())
	{
		String(str, max_size);
	}

	// this must be a global string.
	// because keys are for annotation, they are never read.
	template<size_t i>
	void Key(const char (&)[i])
	{
	}

	void StartObject() {}
	void EndObject() {}
	void StartArray() {}
	void EndArray() {}
};

// This is like rj::MemoryStream but Tell() will go beyond the size (for error checking).
// the problem with rj::StringStream is that it won't work with BinaryReader,
// because rj::StringStream doesn't check for overrun because NULL is used for EOF,
// but BinaryReader cant check for a NULL terminater because the data is binary.
// So for BinaryReader, you have to use this or else Bad Things Will Happen (TM)
// This is 99% copy pasted from rj::MemoryStream, but modified for safety.
struct KsonMemoryStream
{
	typedef char Ch;

	const char* src; //!< Current read position.
	const char* head; //!< Original head of the string.
	const char* end;

	explicit KsonMemoryStream(const char* src_, const char* end_)
	: src(src_)
	, head(src_)
	, end(end_)
	{
	}

	char Peek() const
	{
		return (src >= end ? '\0' : *src);
	}
	char Take()
	{
		// the comma operator is very important
		return (src >= end ? (src++, '\0') : *src++);
	}
	size_t Tell() const
	{
		return static_cast<size_t>(src - head);
	}

	char* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	void Put(char)
	{
		ASSERT(false);
	}
	void Flush()
	{
		ASSERT(false);
	}
	size_t PutEnd(char*)
	{
		ASSERT(false);
		return 0;
	}
};

// the callback signature is <size_t(char* buffer, size_t read_num)> returns bytes read.
// This is copy pasted from rapidjson::FileReadStream, but modified for use by RWops.
template<class Callback>
class KsonCB_ReadStream
{
  public:
	typedef char Ch; //!< Character type (byte).

	KsonCB_ReadStream(Callback cb_, char* buffer, size_t bufferSize)
	: cb(cb_)
	, buffer_(buffer)
	, bufferSize_(bufferSize)
	, bufferLast_(0)
	, current_(buffer_)
	, readCount_(0)
	, count_(0)
	, eof_(false)
	{
		Read();
	}

	Ch Peek() const
	{
		return *current_;
	}
	Ch Take()
	{
		Ch c = *current_;
		Read();
		return c;
	}
	size_t Tell() const
	{
		return count_ + (current_ - buffer_);
	}

	// Not implemented
	void Put(Ch)
	{
		ASSERT(false);
	}
	void Flush()
	{
		ASSERT(false);
	}
	Ch* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	size_t PutEnd(Ch*)
	{
		ASSERT(false);
		return 0;
	}

  private:
	void Read()
	{
		if(current_ < bufferLast_)
		{
			++current_;
		}
		else if(!eof_)
		{
			count_ += readCount_;
			readCount_ = cb(buffer_, bufferSize_);
			bufferLast_ = buffer_ + readCount_ - 1;
			current_ = buffer_;

			if(readCount_ < bufferSize_)
			{
				buffer_[readCount_] = '\0';
				++bufferLast_;
				eof_ = true;
			}
		}
	}

	Callback cb;
	Ch* buffer_;
	size_t bufferSize_;
	Ch* bufferLast_;
	Ch* current_;
	size_t readCount_;
	size_t count_; //!< Number of characters read
	bool eof_;
};

// the callback signature is <size_t(char* buffer, size_t write_num)> returns bytes written.
// You might want to flush if you want RWops::tell to work.
// this is copy pasted from rapidjson::FileWriteStream
template<class Callback>
class KsonCB_WriteStream
{
  public:
	typedef char Ch; //!< Character type. Only support char.

	KsonCB_WriteStream(Callback cb_, char* buffer, size_t bufferSize)
	: cb(cb_)
	, buffer_(buffer)
	, bufferEnd_(buffer + bufferSize)
	, current_(buffer_)
	{
	}

	void Put(char c)
	{
		if(current_ >= bufferEnd_) Flush();

		*current_++ = c;
	}

	void Flush()
	{
		if(current_ != buffer_)
		{
			size_t result = cb(buffer_, static_cast<size_t>(current_ - buffer_));
			if(result < static_cast<size_t>(current_ - buffer_))
			{
				// failure deliberately ignored at this time
				// added to avoid warn_unused_result build errors
			}
			current_ = buffer_;
		}
	}

	// Not implemented
	char Peek() const
	{
		ASSERT(false);
		return 0;
	}
	char Take()
	{
		ASSERT(false);
		return 0;
	}
	size_t Tell() const
	{
		ASSERT(false);
		return 0;
	}
	char* PutBegin()
	{
		ASSERT(false);
		return 0;
	}
	size_t PutEnd(char*)
	{
		ASSERT(false);
		return 0;
	}

  private:
	Callback cb;
	char* buffer_;
	char* bufferEnd_;
	char* current_;
};

template<class Reader, size_t max_line_length = 1024>
void print_json_error(Reader& reader, size_t offset)
{
	char buffer[max_line_length];
	size_t line_n = 0;
	size_t count = 0;
	size_t line_start = 0;
	char* pos = buffer;
	char* end = buffer + max_line_length;
	while(true)
	{
		if(pos < end)
		{
			*pos = reader.Take();
			++count;
			if(*pos == '\n')
			{
				if(offset <= count)
				{
					break;
				}
				++line_n;
				pos = buffer;
				line_start = count;
			}
			else if(*pos == '\0')
			{
				break;
			}
			else
				++pos;
		}
		else
		{
			char c = reader.Take();
			++count;
			if(c == '\n')
			{
				if(offset <= count)
				{
					break;
				}
				++line_n;
				pos = buffer;
				line_start = count;
			}
			else if(c == '\0')
			{
				break;
			}
		}
	}
	if(offset <= count)
	{
		// clear any control values (mainly for windows \r\n)
		char* line_end = std::remove_if(buffer, pos, [](unsigned char _1) {
			return _1 != '\n' && _1 != '\t' && (_1 < 32 || _1 == 127);
		});

		*line_end = '\0';

		// tabs to spaces because it makes the column index clearer.
		std::replace(buffer, line_end, '\t', ' ');

		serrf(
			"Line: %zu\n"
			"Col: %zu\n"
			">>>%s\n",
			line_n + 1,
			offset - line_start + 1,
			buffer);
	}
	else
	{
		ASSERT(false && "unreachable");
	}
}

struct internal_rwops_read_callback
{
	RWops* file;
	size_t operator()(char* memory, size_t read_num) const
	{
		return file->read(memory, 1, read_num);
	}
};

struct internal_rwops_write_callback
{
	RWops* file;
	size_t operator()(char* memory, size_t write_num) const
	{
		return file->write(memory, 1, write_num);
	}
};

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_json_memory(
	Callback cb, const char* file_memory, size_t file_size, const char* info = "<unspecified>")
{
	ASSERT(file_memory != NULL);
	ASSERT(info != NULL);

	KsonMemoryStream stream(file_memory, file_memory + file_size);

	JsonReader ar(stream);

	bool cb_return = cb(ar);

	if(ar.reader.HasParseError())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: %s\n"
			"Offset: %zu\n",
			info,
			GetParseError_En(ar.reader.GetParseErrorCode()),
			ar.reader.GetErrorOffset());
		// rewind the stream
		stream = KsonMemoryStream(file_memory, file_memory + file_size);
		print_json_error(stream, ar.reader.GetErrorOffset());

		return false;
	}

	// if there was an error expected to be printed
	if(!ar.good())
	{
		size_t offset = stream.Tell();
		serrf(
			"Failed to parse json: `%s`\n"
			"Offset: %zu\n",
			info,
			offset);
		// rewind the stream
		stream = KsonMemoryStream(file_memory, file_memory + file_size);
		print_json_error(stream, ar.reader.GetErrorOffset());
		return false;
	}

	if(!cb_return)
	{
		serrf("Failed to parse json: `%s`\n", info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: incomplete json\n",
			info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}
	return true;
}

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_json_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char read_buffer[1000];
	KsonCB_ReadStream stream(internal_rwops_read_callback{file}, read_buffer, sizeof(read_buffer));

	JsonReader ar(stream);

	bool cb_return = cb(ar);

	if(ar.reader.HasParseError())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: %s\n"
			"Offset: %zu\n",
			info,
			GetParseError_En(ar.reader.GetParseErrorCode()),
			ar.reader.GetErrorOffset());
		// rewind the stream
		if(file->seek(0, SEEK_SET) >= 0)
		{
			print_json_error(stream, ar.reader.GetErrorOffset());
		}
		return false;
	}

	// if there was an error expected to be printed
	if(!ar.good() || !cb_return)
	{
		size_t offset = stream.Tell();
		serrf(
			"Failed to parse json: `%s`\n"
			"Offset: %zu\n",
			info,
			offset);
		// rewind the stream
		if(file->seek(0, SEEK_SET) >= 0)
		{
			print_json_error(stream, offset);
		}
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to parse json: `%s`\n"
			"Error: incomplete json\n",
			info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}
	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_json_memory(Callback cb, rj::StringBuffer& sb, const char* info = "<unspecified>")
{
	ASSERT(info != NULL);
	JsonWriter ar(sb);

	bool cb_return = cb(ar);

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write json: `%s`\n", info);
		serrf("Stream size: %zu\n", sb.GetSize());
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to write json: `%s`\n"
			"Error: failed to write a complete json file\n",
			info);
		serrf("Stream size: %zu\n", sb.GetSize());
		return false;
	}
	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_json_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char write_buffer[1000];
	KsonCB_WriteStream stream(
		internal_rwops_write_callback{file}, write_buffer, sizeof(write_buffer));

	JsonWriter ar(stream);

	bool cb_return = cb(ar);

	// this will NOT be automatically called on the destructor.
	// file->tell() will not work without this.
	stream.Flush();

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write json: `%s`\n", info);
		serrf("Stream size: `%d`\n", file->tell());
		return false;
	}

	if(!ar.is_complete())
	{
		serrf(
			"Failed to write json: `%s`\n"
			"Error: failed to write a complete json file\n",
			info);
		serrf("Stream size: `%d`\n", file->tell());
		return false;
	}
	return true;
}

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_binary_memory(
	Callback cb, const char* file_memory, size_t file_size, const char* info = "<unspecified>")
{
	ASSERT(file_memory != NULL);
	ASSERT(info != NULL);

	KsonMemoryStream stream(file_memory, file_memory + file_size);

	BinaryReader ar(stream);

	bool cb_return = cb(ar);

	if(!ar.good() || !cb_return)
	{
		serrf("Failed to parse binary: `%s`\n", info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", file_size);
		return false;
	}

	// For KsonMemoryStream ss.Tell() will go beyond the max size of the file
	// if you continue to read, but it will not overrun the buffer.
	// Unlike JsonReader, BinaryReader will overrun the buffer.
	// This gets checked after serr_check_error because no error will be printed.
	if(stream.Tell() != file_size)
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: mismatching file end, size: %zu cursor: %zu\n",
			info,
			file_size,
			stream.Tell());
		return -1;
	}

	return true;
}

// callback has a signature <bool(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_read_binary_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char read_buffer[1000];
	KsonCB_ReadStream stream(
		[file](char* buf, size_t read_num) -> size_t { return file->read(buf, 1, read_num); },
		read_buffer,
		sizeof(read_buffer));

	BinaryReader ar(stream);

	bool cb_return = cb(ar);

	// if there was an error expected to be printed
	if(!ar.good() || !cb_return)
	{
		serrf("Failed to parse binary: `%s`\n", info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}

	// some sort of error got printed.
	if(serr_check_error())
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: uncaught serr error\n",
			info);
		serrf("Stream size: %zu\n", stream.Tell());
		return false;
	}

	int cursor = file->tell();
	file->seek(0, SEEK_END);
	int end = file->tell();
	if(cursor != end || cursor == -1)
	{
		serrf(
			"Failed to parse binary: `%s`\n"
			"Error: mismatching file end, size: %d cursor: %d\n",
			info,
			end,
			cursor);
		return -1;
	}

	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_binary_memory(Callback cb, rj::StringBuffer& sb, const char* info = "<unspecified>")
{
	ASSERT(info != NULL);
	BinaryWriter ar(sb);

	bool cb_return = cb(ar);

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write binary: `%s`\n", info);
		serrf("Stream size: %zu\n", sb.GetSize());
		return false;
	}
	return true;
}

// callback has a signature <void(auto &ar)>
// return false if you printed to serr, propogates to return.
template<class Callback>
bool kson_write_binary_stream(Callback cb, RWops* file, const char* info = NULL)
{
	ASSERT(file != NULL);
	ASSERT(file->good());
	ASSERT(file->stream_info != NULL);
	info = (info == NULL ? file->stream_info : info);

	char write_buffer[1000];
	KsonCB_WriteStream stream(
		[file](char* buf, size_t write_num) -> size_t { return file->write(buf, 1, write_num); },
		write_buffer,
		sizeof(write_buffer));

	BinaryWriter ar(stream);

	bool cb_return = cb(ar);

	// this will NOT be automatically called on the destructor.
	// file->tell() will not work without this.
	stream.Flush();

	// some sort of error got printed
	if(!cb_return || serr_check_error())
	{
		serrf("Failed to write binary: `%s`\n", info);
		serrf("Stream size: %d\n", file->tell());
		return false;
	}
	return true;
}